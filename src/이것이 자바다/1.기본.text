자바의 특징
    1. 모든 운영체제에서 실행 가능
    2. 객체지향 프로그래밍
    3. 메모리 자동 정리
    4. 풍부한 무료 라이브러리

운영체제별 JDK
    Open JDK : 무료, GNU GPL version2 라이선스
    Oracle JDK : 개발 및 학습용은 무료, 상업용은 유료. Oracle Teclinology Network 라이선스

바이트코드 파일
    javac(java compiler) 명령어는 소스파일을 컴파일함. 자바 소스파일 -> (javac명령어 실행) -> 바이트코드파일

자바 가상 머신
    바이트코드파일(.class)을 특정 운영체제가 이해하는 기계어로 번역/실행시키는 명령어는 java.
    자바 소스파일 -> (javac명령어 실행) -> 바이트코드파일 -> (java명령어) -> 윈도우용/맥용 JVM

컴파일 된 바이트코트 파일 위치?(27p)
    프로젝트 디렉토리 안 bin 티렉토리에 패키지 디렉토리와 함께 저장됨.

변수 선언
    변수는 하나의 값을 저장할 수 있는 메모리 번지에 붙여진 이름.
    변수에 최초로 값을 대입하는 행위를 변수 초기화라고 함. 초기화되지 않은 변수는 아직 메모리에 할당되지 않아 변수를 통해 메모리값을 읽을 수 없음.
    
    int score; // 변수 선언
    score = 90; // 값 대입

정수 타입(41p)
    메모리 사용 크기(bit) : byte(8), short(16), int(32), long(64)

    2진수  : 0b또는 0B로 시작하고 0, 1로 작성 ex) int x = 0b1011;
    8진수  : 0으로 시작하고 0~7숫자로 작성 ex) int x = 013;
    10진수 : 소수점이 없는 0~9숫자로 작성 ex) int x = 12;
    16진수 : 0x또는 0X로 시작하고 0~9숫자나 A,B,C,D,E,F 또는 a,b,c,d,e,f로 작성 ex) int x = 0xB3;

문자 타입(45p)
    하나의 문자를 작은 따옴표('')로 감싼 것을 문자 리터럴이라고 함. 이것은 유니코드로 변환되어 저장되는데, 세계 각국 문자를 0~65535숫자로 매핑한 국제표준규약.
    char var1 = 'A'; // 65로 대입
    char var2 = '가'; // 44032로 대입
    유니코드가 정수이므로 char타입도 정수 타입에 속함.

실수 타입(47p)
    float  : 4byte(32bit), 유효 소수 이하 자리 7자리
    double : 8byte(64bit), 유효 소수 이하 자리 15자리
    실수는 double이 기본이라 float를 사용하고 싶으면 리터럴 뒤에 f나 F를 붙여야됨.

논리 타입(50p)
    true/false.

문자열 타입(51p)
    작은 따옴표로 감싼 한개의 문자는 char타입이지만 큰따옴표로 감싼 문자들은 유니코드로 변환되지 않음. String을 사용해야됨.
    String var1 = "A";
    String var2 = "홍길동";
    문자열 내부에 역슬래쉬(\)가 붙은 문자를 사용할 수 있고 특정문자 사용 가능(\", \\, \u16진수, \t(탭만큼 띄움), \n(줄바꿈))

자동 타입 변환(55p)
    값의 허용 범위가 작은 타입이 -> 허용범위가 큰 타입으로 대입될 때 발생함.
    byte < short / char < int < long < float < double

강제 타입 변환(57p)
    보통 큰 허용 범위 타입을 작은 타입으로 변환할 수 없지만 강제로 변환이 가능.
    int intVal = (int) doubleVal;

연산식에서 자동 타입 변환
    자바컴파일러는 컴파일 단계에서 연산을 실행, 실행 시 덧셈 연산이 없으므로 실행 성능이 좋아짐.
    다만 정수 리터럴이 아니라 변수가 피연산자로 사용되면 실행 시 연산을 수행함. byte, short타입 변수는 int로 자동 형변환되어 연산 수행.

콘솔로 변수값 출력(69p)
    printf("형식문자열", 값1, 값2...)  
    ex) System.out.printf("이름 : %s", "김자바") // 이름 : 김자바
        System.out.printf("이름 : %1$s, 나이: %2$d", "김자바", 25) // 이름 : 김자바, 나이: 25
        -> 형식 문자열이 포함될 값이 두 개 이상일경우 값의 순번을 포함시켜야함. 1$는 첫번째, 2$는 두번째라는 뜻

키보드 입력 데이터를 변수에 저장(72p)
    Scanner scanner = new Scanner(System.in); // 스캐너 변수선언
    String inputData = scanner.nextLine(); // 엔터가 입력되기 전까지 블로킹상태.

부호/증감 연산자
    부호연산자는 변수의 부호를 유지하거나 변경함.
    + : 피연산자의 부호를 유지 ex) int result +b;
    - : 피연산자의 부호를 변경 ex) int reulst -b;

    증감연산자는 변수의 값을 1증가시키거나 1감소시킴.
    ++피연산자 : 값1증가
    --피연산자 : 값1감소
    피연산자++ : 다른 연산 수행 후 피연산자 값1증가
    피연산자-- : 다른 연산 수행 후 피연산자 값1감소

산술연산자(83p)
     + - * / %(나머지)

오버플로우, 언더플로우
    오버플로우 : 타입이 허용하는 최대값을 벗어나는 것(ex. byte 128)
    언더플로우 : 타입이 허용하는 최소값을 벗어나는 것(ex. byte -128)

나눗셈 연산 후 NaN과 Infinity 처리
    5/0(infinity), 5%0(NaN) 이런 예외가 발생함. 연산 결과가 이것인지 확인하고 다음 연산 수행 권장.
    boolean result = Double.isInfinite(변수);
    boolean result = Double.isNaN(변수);

비교 연산자(90p)
    == != > >= < <=, 문자열의 경우는 == 대신 equals()를 사용함.

논리 연산자
    && 또는 &, || 또는 |, ^, !
    * ^ : XOR. 피연산자가 하나는 true, 하나는 false일 경우에만 true 반환
    * ! : NOT. 피연산자의 논리값을 바꿈

비트 논리 연산자(95p)
    bit단위로 논리 연산 수행. 0과 1이 피연산자가 되므로 2진수 0과 1로 저장되는 정수타입만 피연산자가 될 수 있고, 실수 타입은 안됨.
    & : AND. 두 비트 모두 1일 경우에마 연산결과가 1
    | : OR. 두 비트 중 하나만 1이면 연산결과가 1
    ^ : XOR. 두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산결과가 1 
    ~ : NOT. 보수(????)

대입 연산자(104p)
    단순 대입 연산자
        = : 우측의 피연산자 값을 변수에 저장
    복합 대입 연산자
        += : 변수 = 변수 + 피연산자
        -= : 변수 = 변수 - 피연산자
        *= : 변수 = 변수 * 피연산자
        /= : 변수 = 변수 / 피연산자
        %= : 변수 = 변수 % 피연산자
        &= : 변수 = 변수 & 피연산자
        |= : 변수 = 변수 | 피연산자
        ^= : 변수 = 변수 ^ 피연산자
        <<= : 변수 = 변수 << 피연산자
        >>= : 변수 = 변수 >> 피연산자
        >>>= : 변수 = 변수 >>> 피연산자

삼항(조건) 연산자(105p)
    총 3개의 피연산자를 가짐(피연산자 ? 피연산자 : 피연산자)
    조건식 ? 값 또는 연산식 : 값 또는 연산식 => 조건식이 tur면 콜론 앞의 피연산자가 선택되고, false면 뒤가 선택됨.

연산 방향과 우선순위(107p)
                             연산자                        |   연산방향    | 우선순위
    증감(++, --), 부호(+, -), 비트(~), 논리(!)                |   <=====   |  높음
    산술 ... 
    쉬프트
    비교
    논리
    조건
    대입

if문(113p)
    조건식의 결과에 따라 블록 실행 여부가 결정됨.

switch문(120p)
    괄호 안의 변수값에따라 해당 case로 가서 실행문을 실행시킴. 없다면 default의 실행문 실행.
    괄호에는 정수타입과 문자열타입 변수를 사용할 수 있음(char도 정수타입이니까 가능)
    java12부터는 표현식을 사용할 수 있는데 화살표와 중괄호 사용 가능.
    switch(grade) {
        case 'A', 'a' -> System.out.println("우수회원입니다.");
        case 'B', 'b' -> System.out.println("일반회원입니다.");
        default -> System.out.println("손님입니다.");
    }

for문(126p)
    for(초기화식; 조건식; 증감식;) { 실행문 }

while문(131p)
    while(조건식) { false가 될때까지 실행 }

do-while문(134p)
    do { 실행문 } while(조건식)

break문
    반복문이나 조건문인 switch문을 종료할 때 사용. 

continue문
    반복문인 for, while, do-while 문에서만 사용됨.
    블록 내부에서 실해외면 for문의 증감식 또는 while문의 조건식으로 바로 이동함

데이터타입 분류(146p)
    자바는 크게 기본타입과 참조타입으로 분류됨. 참조타입이란 객체의 번지를 참조하는 타입으로 배열,열거,클래스,인터페이스 타입이 있음.
    기본타입은 값 자체를 저장하지만, 참조타입은 객체가 생성된 메모리 번지를 저장함. 
    변수들은 모두 stack이라는 메모리 영역에 생성되는데, 기본타입은 직접 값을 저장하고있지만 참조타입은 힙 메모리영역의 String객체 번지를 저장.
    * 객체란? : 데이터와 메소드로 구성된 덩어리
    * 객체 = 데이터(필드) + 메소드

메모리 사용 영역
    java명령어로 JVM이 구동되면 JVM은 운영체제에서 할당받은 메모리 영역을 다음과 같이 구분해서 사용.
    메소드영역 : 바이트코드 파일을 읽은 내용이 저장되는 영역. 클래스별로 상수, 정적 필드, 메소드코드, 생성자코드 등이 저장됨.
    힙 영역   : 객체가 생성되는 영역. 객체의 번지는 메소드영역과 스택영역의 상수와 변수에서 참조 가능.
    스택 영역  : 메소드를 호출할때마다 생성되는 프레임이 저장되는 영역. 호출이 끝나면 자동제거됨. 여기서 기본타입과 참조타입변수가 생성&제거됨.
    * 어떤 변수에서도 객체를 참조하지 않으면 해당 객체는 쓰레기로 취급됨. 가비지 컬렉터에 의해 제거.

문자열 타입(155p)
    자바의 문자열은 String객체로 생성됨. 문자열은 String 객체로 생성되고, 객체의 번지가 각각 대입됨.
    문자열 리터럴이 동일하다면 String 객체를 공유하도록 설계되어있음. 동일한 String 객체의 번지가 저장됨. 
    다만 new로 새로운 객체를 생성한다면 다른 String 객체의 번지를 가지게 됨. 내부 문자열만을 비교할 경우 equals()메소드를 사용.

관련 메소드(159p)
    charAt() : 문자열에서 특정 위치의 문자를 얻고싶다면 해당 메소드를 이용. 
    length() : 문자열에서 문자의 개수를 얻고싶을때 사용
    replace() : 특정 문자열을 다른 문자열로 대체
    substring() : 문자열 잘라내기. 변수 1개면 n에서 끝까지 잘라내기, 2개면 start에서 end앞까지 잘라내기
    indexOf() : 특정 문자열의 위치를 찾고자 할 때 사용. 없다면 -1 return
    contains() : 주어진 문자열이 단순히 포함되어있는지만 조사. true/false return
    split() : 특정 구분자를 이용해서 문자열을 분리. 분리된 문자열로 구성된 배열을 얻을 수 있음.

배열타입(167p)
    - 배열은 같은 타입의 값만 관리
    - 배열의 길이는 늘리거나 줄일 수 없음.
    배열 변수 선언(둘다 가능하나 관례적으로 전자를 더 많이 씀)
    int[] intArray;     int intArray[];
    배열 변수는 참조변수. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 주소를 저장.
    타입[] 변수 = new 타입[길이]; // 이런식으로 향후 값들을 저장할 목적으로 배열을 미리 생성할 수도 있음.

다차원배열(178p)
    배열에는 또 다른 배열이 대입될 수 있음. 
    int[][] scores = {{ 80,90,96 },{ 76,88 }}
    int[][] scores = new int[2][3]; // 이런식으로도 선언 가능. int면 다 0으로 초기화됨

객체를 참조하는 배열(186p)
    기본타입 배열은 각 항목에 값을 직접 저장하지만 참조타입(클래스, 인터페이스)배열은 각 항목에 객체의 번지를 저장함.

배열 복사(189p)
    배열은 한번 생성하면 길이 변경 불가. 더 많은 공간이 필요하다면 더 큰 배열을 생성하고 이전 배열로부터 항목을 복사해야됨.
    예를 들어 길이 3인 배열을 5에 복사한다면 1,2,3,0,0 이런식으로 복사됨.
    System.arraycopy()를 사용하면 한줄만으로도 배열 복사를 할 수 있음.

향상된 for문(191p)
    항목의 개수만큼 반복한 후 자동으로 for문 탈출.
    for(타입변수 : 배열) { 실행문 }

main() 메소드의 String[] 매개변수 용도
    String[] args는 첫 스레드인 main에게 데이터를 넘겨주고 싶을 때를 위한 파라미터

열거(Enum)타입(196p)
    데이터 중 한정된 값을 갖는 것들이 있음(ex.요일, 계절 등). 이렇게 한정된 값을 갖는 타입을 열거타입이라고 함.
    enum타입으로 선언 가능(public enum Week{ ... })
    관례적으로 알파벳으로 정의하며, 모두 대문자로 작성하고 단어와 단어 사이는 _로 연결하는게 관례. Week today;처럼 변수 선언하고 써야됨.

객체지향 프로그래밍(204p)
    소프트웨어도 조립품처럼 부품에 해당하는 객체를 먼저 만들고, 이 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 사용함.
    객체란 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것을 말함. 객체는 속성과 동작이 있음(ex.이름, 나이/웃다, 걷다)
    객체들 사이의 상호작용 수단은 메소드. 객체가 다른 객체의 기능을 이용할 때 메소드를 호출하게 됨.

객체지향 프로그래밍의 특징
    - 캡슐화 : 객체의 데이터(필드), 동작(메소드)를 하나로 묶고 실제 구현 내용을 외부에 감추는 것을 말함. 외부는 내부의 구조를 알지 못함.
    - 상속 : 코드의 재사용성을 높여줌 / 유지보수시간 최소화
    - 다형성 : 사용방법은 동일하지만 실행 결과가 다양하게 나오는 성질을 말함. 예를 들어 어떤 타이어를 장착하느냐에 따라 자동차의 성능이 달라짐.
    
클래스 선언(209p)
    클래스 선언은 객체 생성을 위한 설계도를 작성하는 작업. 클래스명은 첫문자 대문자, 캐멀스타일.
    하나의 소스 파일에는 복수 개의 클래스 선언을 포함할 수 있음.
    다만 복수의 클래스 선언이 포함된 소스 파일을 컴파일하면 바이트코드 파일은 클래스 선언 수만큼 생성됨.
    그리고 복수의 클래스를 선언할 때 주의할 점은 소스 파일명과 동일한 클래스만 public class로 선언 가능.

클래스 구성 멤버(214p)
    생성자, 필드, 메소드를 클래스 구성멤버라고 함.
    public class ClassName {
        int fieldName;           // 필드선언 : 필드는 객체의 데이터를 저장하는 역할을 함.
        ClassName() { ... }      // 생성자 선언 : 연산자로 객체를 생성할 때 초기화하는 역할을 담당. 리턴타입이 없고 이름은 클래스와 동일.
        int methodName() { ... } // 메소드 선언 : 객체가 수행할 동작. 함수라고도 함. 객체 내부의 함수는 메소드라고 함.
    }

필드 선언과 사용
    필드는 객체의 데이터를 저장하는 역할을 함. 객체의 데이터에는 고유 데이터, 현재 상태 데이터, 부품 데이터가 있음.
    고유 데이터 : 제작회사, 모델, 색깔 등...
    현재 상태 데이터 : 스피트, rpm 등...
    부품 데이터 : 차체, 엔진, 타이어 등...
    * 필드와 (로컬)변수 차이점 : 필드는 클래스 선언블록에 선언되고, 객체 내부에 존재하고, 객체 내 외부 어디든 사용 가능.
                            (로컬)변수는 생성자/메소드 선언블록에 선언되고, 생성자/메소드 호출 시에만 존재하며, 생성자/메소드 블록 내부서만 사용.
                            
