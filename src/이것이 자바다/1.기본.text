자바의 특징
    1. 모든 운영체제에서 실행 가능
    2. 객체지향 프로그래밍
    3. 메모리 자동 정리
    4. 풍부한 무료 라이브러리

운영체제별 JDK
    Open JDK : 무료, GNU GPL version2 라이선스
    Oracle JDK : 개발 및 학습용은 무료, 상업용은 유료. Oracle Teclinology Network 라이선스

바이트코드 파일
    javac(java compiler) 명령어는 소스파일을 컴파일함. 자바 소스파일 -> (javac명령어 실행) -> 바이트코드파일

자바 가상 머신
    바이트코드파일(.class)을 특정 운영체제가 이해하는 기계어로 번역/실행시키는 명령어는 java.
    자바 소스파일 -> (javac명령어 실행) -> 바이트코드파일 -> (java명령어) -> 윈도우용/맥용 JVM

컴파일 된 바이트코트 파일 위치?(27p)
    프로젝트 디렉토리 안 bin 티렉토리에 패키지 디렉토리와 함께 저장됨.

변수 선언
    변수는 하나의 값을 저장할 수 있는 메모리 번지에 붙여진 이름.
    변수에 최초로 값을 대입하는 행위를 변수 초기화라고 함. 초기화되지 않은 변수는 아직 메모리에 할당되지 않아 변수를 통해 메모리값을 읽을 수 없음.
    
    int score; // 변수 선언
    score = 90; // 값 대입

정수 타입(41p)
    메모리 사용 크기(bit) : byte(8), short(16), int(32), long(64)

    2진수  : 0b또는 0B로 시작하고 0, 1로 작성 ex) int x = 0b1011;
    8진수  : 0으로 시작하고 0~7숫자로 작성 ex) int x = 013;
    10진수 : 소수점이 없는 0~9숫자로 작성 ex) int x = 12;
    16진수 : 0x또는 0X로 시작하고 0~9숫자나 A,B,C,D,E,F 또는 a,b,c,d,e,f로 작성 ex) int x = 0xB3;

문자 타입(45p)
    하나의 문자를 작은 따옴표('')로 감싼 것을 문자 리터럴이라고 함. 이것은 유니코드로 변환되어 저장되는데, 세계 각국 문자를 0~65535숫자로 매핑한 국제표준규약.
    char var1 = 'A'; // 65로 대입
    char var2 = '가'; // 44032로 대입
    유니코드가 정수이므로 char타입도 정수 타입에 속함.

실수 타입(47p)
    float  : 4byte(32bit), 유효 소수 이하 자리 7자리
    double : 8byte(64bit), 유효 소수 이하 자리 15자리
    실수는 double이 기본이라 float를 사용하고 싶으면 리터럴 뒤에 f나 F를 붙여야됨.

논리 타입(50p)
    true/false.

문자열 타입(51p)
    작은 따옴표로 감싼 한개의 문자는 char타입이지만 큰따옴표로 감싼 문자들은 유니코드로 변환되지 않음. String을 사용해야됨.
    String var1 = "A";
    String var2 = "홍길동";
    문자열 내부에 역슬래쉬(\)가 붙은 문자를 사용할 수 있고 특정문자 사용 가능(\", \\, \u16진수, \t(탭만큼 띄움), \n(줄바꿈))

자동 타입 변환(55p)
    값의 허용 범위가 작은 타입이 -> 허용범위가 큰 타입으로 대입될 때 발생함.
    byte < short / char < int < long < float < double

강제 타입 변환(57p)
    보통 큰 허용 범위 타입을 작은 타입으로 변환할 수 없지만 강제로 변환이 가능.
    int intVal = (int) doubleVal;

연산식에서 자동 타입 변환
    자바컴파일러는 컴파일 단계에서 연산을 실행, 실행 시 덧셈 연산이 없으므로 실행 성능이 좋아짐.
    다만 정수 리터럴이 아니라 변수가 피연산자로 사용되면 실행 시 연산을 수행함. byte, short타입 변수는 int로 자동 형변환되어 연산 수행.

콘솔로 변수값 출력(69p)
    printf("형식문자열", 값1, 값2...)  
    ex) System.out.printf("이름 : %s", "김자바") // 이름 : 김자바
        System.out.printf("이름 : %1$s, 나이: %2$d", "김자바", 25) // 이름 : 김자바, 나이: 25
        -> 형식 문자열이 포함될 값이 두 개 이상일경우 값의 순번을 포함시켜야함. 1$는 첫번째, 2$는 두번째라는 뜻

키보드 입력 데이터를 변수에 저장(72p)
    Scanner scanner = new Scanner(System.in); // 스캐너 변수선언
    String inputData = scanner.nextLine(); // 엔터가 입력되기 전까지 블로킹상태.

부호/증감 연산자
    부호연산자는 변수의 부호를 유지하거나 변경함.
    + : 피연산자의 부호를 유지 ex) int result +b;
    - : 피연산자의 부호를 변경 ex) int reulst -b;

    증감연산자는 변수의 값을 1증가시키거나 1감소시킴.
    ++피연산자 : 값1증가
    --피연산자 : 값1감소
    피연산자++ : 다른 연산 수행 후 피연산자 값1증가
    피연산자-- : 다른 연산 수행 후 피연산자 값1감소

산술연산자(83p)
     + - * / %(나머지)

오버플로우, 언더플로우
    오버플로우 : 타입이 허용하는 최대값을 벗어나는 것(ex. byte 128)
    언더플로우 : 타입이 허용하는 최소값을 벗어나는 것(ex. byte -128)

나눗셈 연산 후 NaN과 Infinity 처리
    5/0(infinity), 5%0(NaN) 이런 예외가 발생함. 연산 결과가 이것인지 확인하고 다음 연산 수행 권장.
    boolean result = Double.isInfinite(변수);
    boolean result = Double.isNaN(변수);

비교 연산자(90p)
    == != > >= < <=, 문자열의 경우는 == 대신 equals()를 사용함.

논리 연산자
    && 또는 &, || 또는 |, ^, !
    * ^ : XOR. 피연산자가 하나는 true, 하나는 false일 경우에만 true 반환
    * ! : NOT. 피연산자의 논리값을 바꿈

비트 논리 연산자(95p)
    bit단위로 논리 연산 수행. 0과 1이 피연산자가 되므로 2진수 0과 1로 저장되는 정수타입만 피연산자가 될 수 있고, 실수 타입은 안됨.
    & : AND. 두 비트 모두 1일 경우에마 연산결과가 1
    | : OR. 두 비트 중 하나만 1이면 연산결과가 1
    ^ : XOR. 두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산결과가 1 
    ~ : NOT. 보수(????)

대입 연산자(104p)
    단순 대입 연산자
        = : 우측의 피연산자 값을 변수에 저장
    복합 대입 연산자
        += : 변수 = 변수 + 피연산자
        -= : 변수 = 변수 - 피연산자
        *= : 변수 = 변수 * 피연산자
        /= : 변수 = 변수 / 피연산자
        %= : 변수 = 변수 % 피연산자
        &= : 변수 = 변수 & 피연산자
        |= : 변수 = 변수 | 피연산자
        ^= : 변수 = 변수 ^ 피연산자
        <<= : 변수 = 변수 << 피연산자
        >>= : 변수 = 변수 >> 피연산자
        >>>= : 변수 = 변수 >>> 피연산자

삼항(조건) 연산자(105p)
    총 3개의 피연산자를 가짐(피연산자 ? 피연산자 : 피연산자)
    조건식 ? 값 또는 연산식 : 값 또는 연산식 => 조건식이 tur면 콜론 앞의 피연산자가 선택되고, false면 뒤가 선택됨.

연산 방향과 우선순위(107p)
                             연산자                        |   연산방향    | 우선순위
    증감(++, --), 부호(+, -), 비트(~), 논리(!)                |   <=====   |  높음
    산술 ... 
    쉬프트
    비교
    논리
    조건
    대입

if문(113p)
    조건식의 결과에 따라 블록 실행 여부가 결정됨.

switch문(120p)
    괄호 안의 변수값에따라 해당 case로 가서 실행문을 실행시킴. 없다면 default의 실행문 실행.
    괄호에는 정수타입과 문자열타입 변수를 사용할 수 있음(char도 정수타입이니까 가능)
    java12부터는 표현식을 사용할 수 있는데 화살표와 중괄호 사용 가능.
    switch(grade) {
        case 'A', 'a' -> System.out.println("우수회원입니다.");
        case 'B', 'b' -> System.out.println("일반회원입니다.");
        default -> System.out.println("손님입니다.");
    }

for문(126p)
    for(초기화식; 조건식; 증감식;) { 실행문 }

while문(131p)
    while(조건식) { false가 될때까지 실행 }

do-while문(134p)
    do { 실행문 } while(조건식)

break문
    반복문이나 조건문인 switch문을 종료할 때 사용. 

continue문
    반복문인 for, while, do-while 문에서만 사용됨.
    블록 내부에서 실해외면 for문의 증감식 또는 while문의 조건식으로 바로 이동함

데이터타입 분류(146p)
    자바는 크게 기본타입과 참조타입으로 분류됨. 참조타입이란 객체의 번지를 참조하는 타입으로 배열,열거,클래스,인터페이스 타입이 있음.
    기본타입은 값 자체를 저장하지만, 참조타입은 객체가 생성된 메모리 번지를 저장함. 
    변수들은 모두 stack이라는 메모리 영역에 생성되는데, 기본타입은 직접 값을 저장하고있지만 참조타입은 힙 메모리영역의 String객체 번지를 저장.
    * 객체란? : 데이터와 메소드로 구성된 덩어리
    * 객체 = 데이터(필드) + 메소드

메모리 사용 영역
    java명령어로 JVM이 구동되면 JVM은 운영체제에서 할당받은 메모리 영역을 다음과 같이 구분해서 사용.
    메소드영역 : 바이트코드 파일을 읽은 내용이 저장되는 영역. 클래스별로 상수, 정적 필드, 메소드코드, 생성자코드 등이 저장됨.
    힙 영역   : 객체가 생성되는 영역. 객체의 번지는 메소드영역과 스택영역의 상수와 변수에서 참조 가능.
    스택 영역  : 메소드를 호출할때마다 생성되는 프레임이 저장되는 영역. 호출이 끝나면 자동제거됨. 여기서 기본타입과 참조타입변수가 생성&제거됨.
    * 어떤 변수에서도 객체를 참조하지 않으면 해당 객체는 쓰레기로 취급됨. 가비지 컬렉터에 의해 제거.

문자열 타입(155p)
    자바의 문자열은 String객체로 생성됨. 문자열은 String 객체로 생성되고, 객체의 번지가 각각 대입됨.
    문자열 리터럴이 동일하다면 String 객체를 공유하도록 설계되어있음. 동일한 String 객체의 번지가 저장됨. 
    다만 new로 새로운 객체를 생성한다면 다른 String 객체의 번지를 가지게 됨. 내부 문자열만을 비교할 경우 equals()메소드를 사용.

관련 메소드(159p)
    charAt() : 문자열에서 특정 위치의 문자를 얻고싶다면 해당 메소드를 이용. 
    length() : 문자열에서 문자의 개수를 얻고싶을때 사용
    replace() : 특정 문자열을 다른 문자열로 대체
    substring() : 문자열 잘라내기. 변수 1개면 n에서 끝까지 잘라내기, 2개면 start에서 end앞까지 잘라내기
    indexOf() : 특정 문자열의 위치를 찾고자 할 때 사용. 없다면 -1 return
    contains() : 주어진 문자열이 단순히 포함되어있는지만 조사. true/false return
    split() : 특정 구분자를 이용해서 문자열을 분리. 분리된 문자열로 구성된 배열을 얻을 수 있음.

배열타입(167p)
    - 배열은 같은 타입의 값만 관리
    - 배열의 길이는 늘리거나 줄일 수 없음.
    배열 변수 선언(둘다 가능하나 관례적으로 전자를 더 많이 씀)
    int[] intArray;     int intArray[];
    배열 변수는 참조변수. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 주소를 저장.
    타입[] 변수 = new 타입[길이]; // 이런식으로 향후 값들을 저장할 목적으로 배열을 미리 생성할 수도 있음.

다차원배열(178p)
    배열에는 또 다른 배열이 대입될 수 있음. 
    int[][] scores = {{ 80,90,96 },{ 76,88 }}
    int[][] scores = new int[2][3]; // 이런식으로도 선언 가능. int면 다 0으로 초기화됨

객체를 참조하는 배열(186p)
    기본타입 배열은 각 항목에 값을 직접 저장하지만 참조타입(클래스, 인터페이스)배열은 각 항목에 객체의 번지를 저장함.

배열 복사(189p)
    배열은 한번 생성하면 길이 변경 불가. 더 많은 공간이 필요하다면 더 큰 배열을 생성하고 이전 배열로부터 항목을 복사해야됨.
    예를 들어 길이 3인 배열을 5에 복사한다면 1,2,3,0,0 이런식으로 복사됨.
    System.arraycopy()를 사용하면 한줄만으로도 배열 복사를 할 수 있음.

향상된 for문(191p)
    항목의 개수만큼 반복한 후 자동으로 for문 탈출.
    for(타입변수 : 배열) { 실행문 }

main() 메소드의 String[] 매개변수 용도
    String[] args는 첫 스레드인 main에게 데이터를 넘겨주고 싶을 때를 위한 파라미터

열거(Enum)타입(196p)
    데이터 중 한정된 값을 갖는 것들이 있음(ex.요일, 계절 등). 이렇게 한정된 값을 갖는 타입을 열거타입이라고 함.
    enum타입으로 선언 가능(public enum Week{ ... })
    관례적으로 알파벳으로 정의하며, 모두 대문자로 작성하고 단어와 단어 사이는 _로 연결하는게 관례. Week today;처럼 변수 선언하고 써야됨.

객체지향 프로그래밍(204p)
    소프트웨어도 조립품처럼 부품에 해당하는 객체를 먼저 만들고, 이 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 사용함.
    객체란 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것을 말함. 객체는 속성과 동작이 있음(ex.이름, 나이/웃다, 걷다)
    객체들 사이의 상호작용 수단은 메소드. 객체가 다른 객체의 기능을 이용할 때 메소드를 호출하게 됨.

객체지향 프로그래밍의 특징
    - 캡슐화 : 객체의 데이터(필드), 동작(메소드)를 하나로 묶고 실제 구현 내용을 외부에 감추는 것을 말함. 외부는 내부의 구조를 알지 못함.
    - 상속 : 코드의 재사용성을 높여줌 / 유지보수시간 최소화
    - 다형성 : 사용방법은 동일하지만 실행 결과가 다양하게 나오는 성질을 말함. 예를 들어 어떤 타이어를 장착하느냐에 따라 자동차의 성능이 달라짐.
    
클래스 선언(209p)
    클래스 선언은 객체 생성을 위한 설계도를 작성하는 작업. 클래스명은 첫문자 대문자, 캐멀스타일.
    하나의 소스 파일에는 복수 개의 클래스 선언을 포함할 수 있음.
    다만 복수의 클래스 선언이 포함된 소스 파일을 컴파일하면 바이트코드 파일은 클래스 선언 수만큼 생성됨.
    그리고 복수의 클래스를 선언할 때 주의할 점은 소스 파일명과 동일한 클래스만 public class로 선언 가능.

클래스 구성 멤버(214p)
    생성자, 필드, 메소드를 클래스 구성멤버라고 함.
    public class ClassName {
        int fieldName;           // 필드선언 : 필드는 객체의 데이터를 저장하는 역할을 함.
        ClassName() { ... }      // 생성자 선언 : 연산자로 객체를 생성할 때 초기화하는 역할을 담당. 리턴타입이 없고 이름은 클래스와 동일.
        int methodName() { ... } // 메소드 선언 : 객체가 수행할 동작. 함수라고도 함. 객체 내부의 함수는 메소드라고 함.
    }

필드 선언과 사용
    필드는 객체의 데이터를 저장하는 역할을 함. 객체의 데이터에는 고유 데이터, 현재 상태 데이터, 부품 데이터가 있음.
    초기값이 존재하고 타입별도 다 다름.
    고유 데이터 : 제작회사, 모델, 색깔 등...
    현재 상태 데이터 : 스피트, rpm 등...
    부품 데이터 : 차체, 엔진, 타이어 등...
    * 필드와 (로컬)변수 차이점 : 필드는 클래스 선언블록에 선언되고, 객체 내부에 존재하고, 객체 내 외부 어디든 사용 가능.
                            (로컬)변수는 생성자/메소드 선언블록에 선언되고, 생성자/메소드 호출 시에만 존재하며, 생성자/메소드 블록 내부서만 사용.

생성자 선언과 호출(220p)
    new 연산자는 객체를 생성한 후 생성자를 호출해서 객체를 초기화하는 역할을 함.
    생성자는 메소드와 비슷한 모양을 가지고 있으나 리턴 타입이 없고 클래스명과 동일함. 
    * 객체 초기화란 필드 초기화를 하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것임.
    클래스 선언 : 클래스 변수 = new 클래스(); <-- 클래스() 이부분이 생성자 호출
    기본생성자  : 모든 클래스는 생성자가 존재하며, 하나 이상을 가질 수 있음. [public] 클래스(){} <-- 클래스가 public일 경우

생성자 오버로딩(226p)
    매개값으로 객체의 필드를 다양하게 초기화하기 위해서는 생성자 오버로딩이 필요함. 매개변수를 달리하는 생성자를 여럿 선언하는 것.
    public class Car {
        Car() { ... }
        Car(String model) { ... }
        Car(String model, String color) { ... }
        Car(String model, String color, int maxSpeed) { ... }
    }
    그런데 매개변수 이름만 바꾸는건 오버로딩이 아님.

다른 생성자 호출(229p)
    생성자 오버로딩이 많아질 경우 생성자 간 중복코드가 발생할 수 있음.
    이 경우 공통 코드를 한 생성자에만 집중적으로 작성하고, 나머지 생성자는 this(...)를 사용하여 공통 코드를 가진 생성자를 호출할 수 있음.
    - 중복 코드
    Car(String model) {
        this.model = model;
        this.color = "은색";
        this.maxSpeed = 250;
    }
    Car(String model, String color) {
        this.model = model;
        this.color = color;
        this.maxSpeed = 250;
    }
    Car(String model, String color, int maxSpeed) {
        this.model = model;
        this.color = color;
        this.maxSpeed = maxSpeed;
    }

    - 개선된 코드(Car(1,2,3)이걸 호출하는것)
        Car(String model) {
        this(model, "은색", 250)
    }
    Car(String model, String color) {
        this(model, color, 250)
    }
    Car(String model, String color, int maxSpeed) {
        this.model = model;
        this.color = color;
        this.maxSpeed = maxSpeed;
    }

메소드 선언과 호출(232p)
    메소드 선언은 객체의 동작을 실행 블록으로 정의하는 것을 말하고, 호출은 실행 블록을 실제로 실행하는 것을 말함.
    리턴타입 메소드명(매개변수, ...) {
        실행할 코드 작성하는 곳
    }
    리턴 타입 : 메소드가 실행한 후 호출한 곳으로 전달하는 결과값의 타입을 말함. 리턴값이 없으면 void.
    메소드명  : 첫 문자를 소문자로 시작, 캐멀 스타일.
    매개변수  : 메소드를 호출할 때 전달한 매개값을 받기 위해 사용됨. 
    실행블록  : 메소드 호출 시 실행되는 부분.

메소드 호출(234p)
    메소드 호출이란 메소드 블록을 실행하는 것을 말함. 메소드는 객체의 동작이므로 객체(ex.클래스 선언)가 존재하지 않으면 메소드 호출 불가.

가변길이 매개변수(236p)
    메소드를 호출할때는 매개변수의 개수에 맞게 매개값을 제공해야되는데 만약 가변길이 매개변수를 가지고 있다면 매개변수와 상관없이 값 줄수있음.
    int sum(int ... values) { ... }
    매개값들은 자동으로 배열 항목으로 변환되어 메소드에서 사용됨. 그렇기 때문에 직접 배열을 매개값으로 전달하는 것도 가능.

return문
    return문은 메소드의 실행을 강제종료하고 호출한 곳으로 돌아간다는 의미. return문 이후의 실행문 작성하면 에러남(결코 실행X).

메소드 오버로딩(241p)
    메소드 이름은 같되 매개변수 타입, 개수, 순서가 다른 메소드를 여러 개 선언하는것을 말함.

인스턴스 멤버(244p)
    필드와 메소드는 선언 방법에 따라 인스턴스멤버/정적멤버로 분류할 수 있음.
    - 인스턴스 멤버 : 객체에 소속된 멤버(객체를 생성해야만 사용 가능)
    - 정적 멤버    : 클래스에 고정된 멤버(객체 없이도 사용 가능)

인스턴스 멤버 선언 및 사용
    public class Car {
        int gas; // 인스턴스 필드 생성
        void setSpeed(int speed) { ... } // 인스턴스 메소드 선언
    }

this 키워드
    객체 내부에서는 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있음. 객체는 자신을 this라고 칭함. 인스턴스 필드인걸 강조할 경우 사용.

정적 멤버(247p)
    자바는 클래스 로더를 이용해서 클래스를 메소드 영역에 저장하고 사용함. 정적 멤버는 메소드 영역의 클래스에 고정적으로 위치하는 멤버.
    public class 클래스 {
        static 타입 필드 [= 초기값]; // 정적 필드 선언
        static 리턴타입 메소드(매개변수, ...) { ... } // 정적 메소드
    }
    객체마다 가지고있을 필요성이 없는 공용 필드는 정적 필드로 선언하는게 좋음.

정적 블록(250p)
    복잡한 초기화 작업이 필요한 경우 다음와 같이 블록으로 사용할 수도 있음.
    static {
        info = company + "-" + model; // print하면 myCompany-LCD 이런식으로 나옴
    }

인스턴스 멤버 사용 불가
    정적 메소드/정적 블록은 객체가 없어도 실행되기 때문에 내부에 인스턴스 필드/인스턴스 멤버 사용 불가. 또한 this도 사용불가.

final필드와 상수(254p)
    인스턴스필드/정적 필드는 언제든 값 변경이 가능. 그러나 경우에 따라 값을 읽기만 허용해야하는 경우가 있음.
    final 타입 필드 [= 초기값];
    필드에 초기값을 주는 방법은 총 2가지
    1. 필드 선언 시 초기값 대입
    2. 생성자에서 초기값 대입

상수 선언(256p)
    불변의 값은 static이면서 final로 선언하면 됨. 상수명은 대문자로 작성하는게 원칙.
    static final 타입 상수 [= 초기값];

패키지(258p)
    자바의 패키지는 단순히 디렉토리만을 의미하는것이 아니고, 클래스의 일부이며 클래스를 식별하는 용도로 사용됨. 
    주로 개발 회사 도메인 역순으로 만듬.

import문(260p)
    같은 패키지 내에서라면 클래스는 아무 조건 없이 사용할 수 있지만, 다른 패키지의 클래스를 사용하기위해서는 import를 사용해야됨.
    import com.hankook.*; // 근데 만약 클래스 이름 전체를 사용할거면 import문 필요없음... com.hankook.Tire tire 등...

접근제한자(264p)
    public < protected < default < private (->로 갈수록 접근제한자이 강화)

클래스의 접근제한
    클래스를 어디에서나 사용할 수 있는건 아님. 어떤 접근제한을 갖느냐에 따라 사용 가능여부가 결정됨.
    클래스 : public, default 접근제한을 가질 수 있음.

접근제한(266p)
    생성자 : public, default, private 접근제한을 가질 수 있음(아무데서나 호출할수있는게 아님)
    필드 / 메소드 : public, default, private

Getter/Setter(271p)
    객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성(결점이 없는 성질)이 깨질 수 있음.
    그렇기때문에 객체지향 프로그래밍에서는 직접적인 외부에서의 필드 접근을 막고 메소드를 통해 필드에 접근하는 것을 선호함.
    public double getSpeed() {
        double km = speed * 1.6;
        return km;
    }
    필드 타입이 boolean인 경우에는 is로 시작하는게 관례.

싱글톤 패턴(275p)
    애플리케이션 전체에서 단 한개의 객체만 생성해서 사용하고 싶을 때 사용.
    핵심은 생성자를 private 접근제한해서 외부에서 new 연산자로 생성자를 호출할 수 없도록 막는 것.
    public class 클래스 {
        private static 클래스 singleton = new 클래스(); // 정적 필드 선언, 미리 객체를 생성해서 초기화시킴. 외부에서 변경못하도록 막음.
        private 클래스() {} // private 접근 권한을 갖는 생성자 선언
        public static 클래스 getInstance() { // 외부에서 객체를 얻는 유일한 방법. 리턴하는 객체는 정적 필드가 참조하는 싱글톤 객체.
            return singleton;
        }
    }

상속(286p)
    상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 중복되는 코드를 줄일 수 있음.
    또한 클래스의 수정을 최소화할 수 있음(부모만 수정하면 자식클래스도 간편하게 변경 가능)
    public class 자식클래스 extends 부모클래스 { } // 클래스 상속. 다중상속을 허용하지 않음.

부모 생성자 호출(290p)
    자식클래스 변수 = new 자식클래스();
    위 코드는 사실 자식 객체만 생성되는것처럼 보이지만 사실은 부모객체가 먼저 생성되고 그 다음에 자식이 생성된것.
    모든 객체는 생성자를 호출해야만 생성됨(부모 또한). 그렇다면 부모 객체의 생성자는 어디서 호출된것인지???
    public 자식클래스() {
        super(); <--- 이부분에서 호출됨. 컴파일 과정에서 자동 추가.
        ...
    }

메소드 오버라이딩(295p)
    상속된 메소드를 자식 클래스에서 재정의하는 것. 다음 규칙에 주의
    - 부모 메소드의 선언부(리턴타입, 메소드이름, 매개변수)와 동일해야됨.
    - 접근 제한을 더 강하게 오버라이딩 할 수 없음(public -> private로 변경 불가)
    - 새로운 예외를 throws할 수 없음.
    자바에서는 개발자의 실수를 줄여주기 위해 @Override 어노테이션을 제공(자동생성 기능도 있음).

부모 메소드 호출
    메소드를 재정의하면, 부모 메소드는 숨겨지고 자식 메소드만 사용되기 때문에 중복된 내용을 자식 메소드도 가지고있어야함.
    100줄이 있다면 100줄 다 적어야됨. 그런데 super.method()를 사용하면 숨겨진 부모 메소드를 호출할 수 있음.

final클래스 / final메소드(300p)
    필드 선언 시 final을 붙이면 값 변경 불가능. 그렇다면 클래스와 메소드의 final은? -> 상속과 관련이 있음. 상속/오버라이딩 불가.
    public final class 클래스 { ... }
    public final 리턴타입 메소드(매개변수, ...) { ... }

protected 접근제한자(303p)
    제한대상 - 필드,생성자,메소드 / 제한범위 - 같은패키지나 자식객체만 사용 가능.

자동 타입 변환(307p)
    클래스에도 타입 변환이 있는데, 클래스 간의 타입 변환은 상속 관계에 있는 클래스 사이에서 발생함.
    부모타입 변수 = 자식타입객체; <-- 자식에서 부모로 자동 타입 변환(ex. 고양이는 -> 동물이다)
    서로 상속관계에 있는 객체는 참조변수가 같다고 나옴(cat == animal). 다만 형제는 다르다고나옴(cat != dog)

강제 타입 변환(312p)
    자식 -> 부모로 자동변환되지만, 부모 -> 자식은 자동변환되지 않음. 다만 캐스팅 연산자로 강제 타입 변환이 가능.
    Parent parent = new Child(); // 자동 형변환
    Child child = (Child) parent; // 깅제 형변환
    자식 객체가 부모 타입으로 자동 변환하면 부모 타입에 선언된 필드만 사용 가능하다는 제약사항이 따름.
    
다형성(314p)
    사용방법은 동일하지만 실행 결과가 다양하게 나오는 것을 말함(ex.자동차의 부품을 교환하면 성능이 다르게 나옴)
    즉, 자식1 자식2가 부모의 메소드를 오버라이딩하고 있다면 부모 메소드 호출 시 오버라이딩된 메소드가 호출됨. 실행결과도 다름(다형성)
    자동 타입 변환 + 메소드 오버라이딩 = 다형성

필드 다형성(315p)
    필드 타입은 동일하지만(사용방법 동일) 대입되는 객체가 달라져서 실행 결과가 다양하게 나올 수 있는 것을 말함.
    예를 들어 Car클래스에 Tire필드를 HankookTire 또는 KumhoTire 객체처럼 다양하게 대입할 수 있음(ch07.sec08.exam01)

매개변수 다형성(319p)
    다형성은 필드보다는 메소드를 호출할 때 많이 발생. 
    예를 들어 메소드가 클래스타입의 매개변수를 가지고, 호출할때 동일한타입 or 자식객체를 제공할 수도 있음(다형성)

객체 타입 확인(322p)
    boolean result = 객체 instanceof 타입; -> 우항의 타입이 맞으면 true/아니면 false

추상 클래스(326p)
    추상이란 실체 간에 공통되는 특성을 추출한 것. 예를 들어, 새/곤충/물고기의 공통점은 동물.
    객체를 생성할 수 있는 클래스가 실제 클래스라면, 이 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스를 추상클래스라고 함.
    추상클래스는 new 연산자를 사용해서 객체를 직접 생성할 수 없음.
    public abstract class 클래스명 {
        필드, 생성자, 메소드 ...
    }

추상메소드와 재정의(329p)
    메소드 선언부(리턴타입, 메소드명, 매개변수)만 동일하고 실행내용은 다르게 하고 싶은 경우 추상메소드를 작성할 수 있음.
    추상메소드는 자식클래스에서 반드시 재정의(오버라이딩)해서 실행 내용을 채워야됨.
    public abstract class Animal {
        abstract void sound(); // abstract가 붙고 중괄호가 없음.
    }

봉인된 클래스(332p)
    원래는 final 클래스를 제외하고 모든 클래스가 부모가 될 수 있었지만, 자바15부터는 무분별한 자식클래스 생성을 막기위해 봉인된 클래스가 생김.
    public sealed class Person permits Employee, Manager { ... } // Employee, Manager만 자식클래스가 될 수 있음.
    자식클래스의 경우 final로 선언해서 아예 상속을 못하게하거나 non-sealed를 붙여서 봉인을 해제할 수 있음(상속가능).

인터페이스(342p)
    인터페이스는 사전적 의미로 두 장치를 연결하는 접속기를 말함.
    객체A --메소드호출/리턴값-- 인터페이스 -- 메소드호출/리턴값 -- 객체B
    여기서 객체 A와 B가 직접 호출하면 안되냐는 의문이 나올 수 있는데, 만약 객체B가 C로 교체된다면 A의 소스코드를 C로 변경하는 작업이 필요함.
    인터페이스를 사용하면 굳이 그런 작업이 필요 없어짐. 이렇기 때문에 인터페이스는 다형성 구현에 주된 기술로 이용됨.

인터페이스와 구현 클래스 선언(343p)
    public interface 인터페이스명 { ... }  // public, default 사용 가능
    인터페이스 안에는 추상메소드를 가질 수 있음(선언부만 있고 실행부인 중괄호가 없는 메소드).

구현클래스 선언(344p)
    객체 A가 인터페이스의 추상메소드를 호출하면 인터페이스는 객체 B의 메소드를 실행함. 
    B는 인터페이스에 선언된 추상메소드와 동일한 선언부를 가진 메소드를 가지고 있어야됨.
    public class B implements 인터페이스명 { ... }
    implements는 해당 클래스가 인터페이스를 통해 사용할 수 있음을 의미함.

    main()메소드 --turnOn() 호출--> RemoteControl인터페이스 --turnOn() 호출--> Television객체
               <------void------                      <-----void-------

변수 선언과 구현 객체 대입(346p)
    인터페이스도 하나의 타입이므로 변수의 타입으로 사용할 수 있음. 
    인터페이스는 참조 타입에 속하므로 인터페이스 변수에는 객체를 참조하고 있지 않다는 뜻으로 null을 대입할 수 있음.
    RemoteControl rc = null;
    인터페이스를 통해 구현 객체를 사용하려면 인터페이스에 구현 객체를 대입해야됨(구현 객체의 번지를 대입하는것)
    rc = new Television();
    rc에는 RemoteControll을 구현한 어떤 객체든 대입할 수 있음.

상수 필드(349p)
    인터페이스는 불변의 상수 필드를 멤버로 가질 수 있음.
    [public static final] 타입 상수명 = 값;    
    인터페이스에서 선언된 필드는 모두 public static final 특성을 가지기 때문에 생략하더라도 자동으로 컴파일 때 붙게됨.
    public interface RemoteControl {
        int MAX_VOLUME = 10; // 상수 선언
        int MIN_VOLUME = 0;  // 상수 선언
    }
    상수는 구현 객체와 상관없는 인터페이스 소속 멤버이므로 RemoteControl.MAX_VOLUME 처럼 인터페이스로 바로 접근해서 상수를 읽을 수 있음.

추상 메소드(350p)
    인터페이스는 추상메소드를 멤버로 가질 수 있음. public abstract를 생략하더라도 자동으로 붙게 된다.
    구현 클래스에서 추상 메소드를 재정의할 때 주의점은 인터페이스-추상메소드는 기본적으로 public 접근제한을 가짐. 그래서 더 낮은 접근제한 불가.

디폴트 메소드(354p)
    인터페이스에는 완전한 실행 코드를 가진 디폴드 메소드를 선언할 수 있음(완전한 실행코드란, 중괄호가 있는 실행부가 있는 것).
    선언 방법은 클래스 메소드와 동일하지만 차이점은 default키워드가 리턴 타입 앞에 붙음.
    [pulic] default 리턴타입 메소드명(매개변수, ....) { ... }
    디폴트 메소드는 구현 객체가 필요한 메소드임(ch08.sec05 참고)
    * 구현 객체가 필요하다는 말은 인터페이스 자체에서 호출할 수 없고 인터페이스를 구현한 클래스의 인스턴스를 통해서만 호출할 수 있다는 뜻.

정적 메소드(359p)
    인터페이스에는 정적 메소드도 선언 가능. 추상메소드와 디폴트메소드는 구현 객체가 필요하지만 정적 메소드는 인터페이스만으로 호출 가능. 
    [public | private] static 리턴타입 메소드명(매개변수, ...) { ... } // public을 생략해도 자동으로 붙음.

private메소드(361p)
    인터페이스의 상수필드, 추상메소드, 디폴트메소드, 정적메소드 모두 public 접근제한을 가짐(생략해도 자동 컴파일)
    private메소드 : 구현 객체가 필요한 메소드
    public메소드 : 구현 객체가 필요없는 메소드
    private메소드는 디폴트 메소드 안에서만 호출이 가능하고 private 정적메소드는 디폴트메소드나 정적메소드 안에서도 호출 가능.
    private메소드의 용도는 디폴트와 정적메소드들의 중복 코드를 줄이기 위함(ch08.sec07)

다중 인터페이스 구현(364p)
    구현 객체는 여러개의 인터페이스를 implements할 수 있음. 
    public class 구현클래스명 implements 인터페이스A, 인터페이스B {
        // 모든 추상메소드 재정의
    }

인터페이스 상속(367p)
    인터페이스도 다른 인터페이스를 상속할 수 있으며 클래스와는 달리 다중상속을 허용함(클래스는 다중상속 허용X)
    public interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2 { ... }
    자식인터페이스의 구현 클래스는 자식의 메소드 + 부모인터페이스의 모든 추상메소드를 재정의해야됨. 

타입변환(370p)
    인터페이스 타입 변환은 인터페이스와 구현클래스 간에 발생. 
    인터페이스 변수에 구현 객체를 대입하면 구현 객체는 인터페이스 타입으로 자동변환됨.
    반대로 인터페이스 타입을 구현클래스 타입으로 변환시킬 수 있는데 이때는 강제 타입변환 필요.
    자동 타입 변환 : 인터페이스 변수 = 구현객체; // 인터페이스 변수로 자동변환. A의자식이 B,C. 자식의자식이 D,E일때 모두 A로 자동변환 가능
    강제 타입 변환 : 구현클래스 변수 = (구현클래스)인터페이스변수; // 구현클래스 변수로 강제 타입변환.
    다만 강제타입변환된 경우 인터페이스에 선언된 메소드만 사용 가능.

다형성(375p)
    인터페이스를 통해 다형성 구현을 많이 함.
    메소드 재정의 + 자동타입변환 => 다형성
    
    public class Car {
        Tire tire1 = new HankookTire();
        Tire tire2 = new KumhoTire();
    }
    Car myCar = new Car();
    myCar.tire1 = new KumhoTire();
    tire1과 2 필드에 어떤 타이어 구현 객체가 대입되어도 Car객체는 타이어 인터페이스에 선언된 메소드만 사용하게 됨.

매개변수의 다형성(380p)
    매개변수타입을 인터페이스로 선언하면 메소드 호출 시 다양한 구현 객체 대입 가능.
    public class Driver {
        void drive( Vehicle vehicle ) { // 구현객체가 대입될 수 있도록 매개변수를 인터페이스타입으로 선언
            vehicle.run();
        }
    }
    위 코드에서는 Vehicle을 구현하는 객체는 뭐든 매개값으로 줄 수 있음.

객체 타입 확인(384p)
    인터페이스에서도 instanceof 사용할 수 있음. 예시로 Vehicle 인터페이스 변수에 대입된 객체가 Bus인지 확인하는 코드.
    if( vehicle instanceof Bus ) {
        // 실행문
    }

봉인된 인터페이스(386p)
    자바15부터 무분별한 자식생성을 막기위해 sealed인터페이스를 사용할수있음. 
    봉인된 인터페이스를 상속하지만 봉인을 해제하려면 non-sealed 키워드를 선언해야됨.

중첩 클래스(396p)
    클래스가 여러 클래스와 관계를 맺는 경우에는 독립적으로 선언하는게 좋지만, 특정 클래스만 관계를 맺을 때는 중첩클래스로 선언하는게 좋음.
    중첩클래스란 클래스 내부에 선언한 클래스를 말하는데, 클래스의 멤버를 쉽게 사용할 수 있고 외부에는 중첩관계클래스를 감춤으로써 코드복잡성을 낮춤.
    * 멤버클래스 - 인스턴스 멤버 클래스 : A객체를 생성해야만 B객체 생성 가능
        class A {
            class B { ... }
        }
    * 멤버클래스 - 정적 멤버 클래스 : A객체 없이도 B객체 생성 가능    
        class A {
            static class B { ... }
        }
    * 로컬클래스 : mothod가 실행할때만 B객체 생성 가능
        class A {
            void method() {
                class B { ... }
            }
        }
    중첩클래스도 클래스이기 때문에 컴파일하면 바이트코드 파일이 별도로 생성됨(ex.A $ B.class) A가 밖, B가 안. 로컬클래스는 $1

인스턴스 멤버 클래스(397p)
    [public] class A {
        [public | private] class B { // 인스턴스 멤버 클래스
        }
    }
    A클래스에 선언된 B클래스를 인스턴스 멤버 클래스라고 함.

정적 멤버 클래스(400p)
    [public] class A {
        [public | private] static class B { // 정적 멤버 클래스
        }
    }
    위처럼 static 키워드와 함께 A클래스의 멤버로 선언된 B클래스를 말함.
    접근제한자에 따른 정적멤버클래스 접근범위.
    - public static class B {} : 타 패키지에서 B클래스 사용 가능
    - static class B {} : 같은 패키지에서만 B클래스 사용 가능
    - private static class B {} : A클래스 내부에서만 B클래스 사용 가능

로컬 클래스(403p)
    생성자 또는 메소드 내부에서 다음과 같이 선언된 클래스를 말함.
    로컬클래스는 생성자와 메소드가 실행될 동안에만 객체를 생성할 수 있음.
    [public] class A {
        // 생성자
        public A() {
            class B {} // 로컬클래스
        }

        // 메소드
        public void method() {
            class B {} // 로컬클래스
        }
    }

바깥클래스의 멤버접근제한(408p)
    중첩클래스는 바깥클래스와 긴밀한 관계를 맺으면서 바깥클래스의 멤버에 접근 가능. 그러나 중첩클래스가 어떻게 선언되느냐에따라서 접근제한.
    - 인스턴스멤버 클래스 : 바깥클래스의 모든 필드와 메소드(바깥클래스의 사용 가능 멤버)
    - 정적멤버 클래스 : 바깥클래스의 정적 필드와 정적 메소드(바깥클래스의 사용 가능 멤버)

바깥 클래스의 객체 접근(409p)
    중첩클래스 내부에서 this는 해당 중첩 클래스의 객체를 말함. 만약 중첩클래스 내부에서 바깥클래스 객체를 얻으려면 바깥클래스.this.
    바깥클래스이름.this -> 바깥객체

중첩 인터페이스(411p)
    클래스의 멤버로 선언된 인터페이스를 말함. 사용하는 이유는 해당 클래스와 긴밀한 관계를 맺는 구현 객체를 만들기 위함.
    안드로이드와 같은 UI프로그램에서 이벤트를 처리할 목적으로 많이 사용함(ex.버튼 클릭 시 이벤트 처리 객체)
    class A {
        [public | private] [static] interface B { // 중첩 인터페이스. 중첩 인터페이스는 암시적으로 static임(생략가능)
            // 상수 필드
            // 추상 메소드
            // 디폴트 메소드
            // 정적 메소드
        }
    }

익명 객체(415p)
    익명 객체란 이름이 없는 객체를 말함. 명시적으로 클래스를 선언하지 않아 비교적 쉽게 객체 생성 가능.
    클래스를 상속하거나 인터페이스를 구현해야만 생성 가능.
    - 익명 자식 객체 : 클래스를 상속해서 만들 경우
    - 익명 구현 객체 : 인터페이스를 구현해서 만들 경우

익명자식객체
    부모클래스를 상속받아 생성됨. 부모타입의 필드, 로컬변수, 매개변수의 값으로 대입할 수 있음.
    new 부모생성자(매개값, ...) {
        // 필드, 메소드...
    }

익명 구현 객체(418p)
    익명 객체는 인터페이스 타입의 필드, 로컬변수, 매개변수의 값으로 대입할 수 있음. 안드로이드와 같은 UI프로그램에서 이벤트 처리하는 객체로 많이 사용.
    new 인터페이스() {
        // 필드, 메소드...
    }

라이브러리(430p)
    라이브러리는 프로그램 개발 시 활용할 수 있는 클래스와 인터페이스들을 모아놓은 것을 말함. 일반적으로 JAR압축파일 형태로 존재(JavaARchive)
    라이브러리를 이용하려면 JAR파일을 ClassPath에 추가해야됨(classPath란 클래스를 찾기위한 경로)

모듈(437p)
    자바9부터 지원하는 모듈은 패키지관리 기능까지 포함된 라이브러리. 
    일반 라이브러리는 내부에 포함된 모든 패키지에 외부 프로그램 접근이 가능하지만, 모듈은 일부 패키지를 은닉할 수 있음(접근불가)
    모듈도 라이브러리이기 때문에 jar파일 형태로 배포 가능.

430p부터 이클립스 모듈

예외(466p)
    일반 예외 : 컴파일러가 예외처리코드 여부를 검사하는 예외
    실행 예외 : 컴파일러가 예외처리코드 여부를 검사하지 않는 예외
    try {
        // 예외 발생 가능 코드
    } catch(예외클래스 e) {
        // 예외 처리
    } finally {
        // 항상 실행
    }
    catch블록이 여러개라도 catch블록은 단 하나만 실행됨. 

리소스 자동 닫기(475p)
    리소스란 데이터를 제공하는 객체. 사용하기 위해 열어야하며, 끝난 다음에는 닫아야함. 사용 중 예외가 발생해도 안전하게 닫아야됨.

예외 떠넘기기(479p)
    메소드 내부에서 예외가 발생할때는 try-catch가 기본이지만, 메소드를 호출한 곳으로 넘길때는 throws를 사용하면 됨.
    public void method1() {
        try {
            method2();
        } catch(ClassNotFoundException e) { // 여기서 예외처리 하게됨
            System.out.println("예외처리 : " + e.getMessage());
        }
    }
    public void method2() trhows ClassNotFoundException { // 호출한곳으로 예외 떠넘기기
        Class.forName("java.lang.String2");
    }
    나열해야되는 예외가 많은 경우에는 throws Exception이나 throws Throwable만으로도 모든 예외를 떠넘길 수 있음

사용자 정의 예외(481p)
    ex.잔고보다 더 많은 출금 요청이 들어온 경우 등 표준 라이브러리에 존재하지 않는 예외를 정의해서 사용할 수 있음.
    public class InsufficientException extends Exception { // 일반 예외로 선언(실행예외는 RuntimeException)
        public InsufficientException() {
            // 두개의 생성자 선언
        }
        public InsufficientException(String message) {
            super(message);
        }
    }

API 도큐먼트(494p)
    자바 표준 모듈에서 제공하는 라이브러리는 방대해서 쉽게 찾아서 사용할 수 있도록 도와주는 API도큐먼트가 있음.
    https://docs.oracle.com/en/java/javase/index.html
    클래스 정의를 보려면 선언부를 보면 됨. 상속관계도 볼 수 있고 구성 멤버도 볼 수 있음(summary)

java.base 모듈(497p)
    모든 모듈이 의존하는 기본 모듈. 모듈 중 유일하게 requires하지 않아도 사용 가능. 아래는 주요 패키지
    java.lang : 기본 클래스 제공
    java.util : 자료구조와 관련된 컬렉션 클래스 제공
    java.text : 날짜 및 숫자를 원하는 형태의 문자열로 만들어줌
    java.time : 날짜 및 시간을 조작하거나 연산
    java.io : 입출력 스트림 클래스 제공
    java.net : 네트워크 통신과 관련된 클래스 제공
    java.nio : 데이터 저장을 위한 Buffer 및 입출력 클래스 제공

Object클래스(498p)
    클래스 선언 시 extends키워드로 다른 클래스를 상속하지 않으면 암시적으로 java.lang.Object클래스를 상속하게 됨.
    그렇기 때문에 Object가 가진 메소드는 모든 객체에서 사용 가능.
    equals() : 객체의 번지를 비교하고 boolean값을 리턴

객체 해시코드(501p)
    객체 해시코드란 객체를 식별하는 정수. Object의 hashCode()메소드는 객체의 메모리번지를 이용해서 해시코드를 생성해서 객체마다 다른 정수값 리턴.
    equals()와 비슷한데 두 객체가 동등한지를 비교할 때 주로 사용.
    hashCode()리턴값이 같고 equals()리턴값이 같으면 동등객체, equals()만 달라도 다른 객체.
    HashSet은 동등 객체를 중복 저장하지 않는다는 특징이 있음(hashCode()와 equals() 메소드를 이용해서 동등 객체인지 판단)

객체 문자 정보(505p)
    Object의 toString()메소드는 객체의 문자정보를 리턴함(클래스명@16진수해시코드)
    
레코드선언(507p)
    dto를 작성할 때 반복적으로 사용되는 코드를 줄이기 위해 자바14부터 레코드가 도입됨.

롬복(509p)
    자동 코드 생성 라이브러리. 레코드와 비슷하지만 차이점은 필드가 final이 아니며, 값을 읽는 getter는 getXxx(또는 isXxx), setter는 setXxx

System클래스(514p)
    자바 프로그램은 JVM위에서 실행되니 운영체제의 모든 기능을 자바 코드로 직접 접근하긴 힘듬. 
    그러나 java.lang패키지의 System클래스를 이용하면 운영체제 일부 기능 사용 가능(ex.프로그램 종료, 키보드입력, 콘솔출력, 현재시간읽기...)
    * 필드
        - out : 콘솔에 문자 출력
        - err : 콘솔에 에러내용 출력
        - in : 키보드 입력
    * 메소드
        - exit(in status) : 프로세스 종료
        - currentTimeMills() : 현재 시간을 밀리초 단위의 long값으로 리턴
        - nanoTime() : 현재 시간을 나노초 단위의 long값으로 리턴
        - getProperty() : 운영체제와 사용자정보 제공
        - getenv() : 운영체제의 환경변수정보 제공

시스템 프로퍼티 읽기(519p)
    자바 프로그램이 시작될 때 자동설정되는 시스템의 속성을 말함(ex.OS종류, 자바버전, 사용자정보 등...)
    System.getProperty("os.name") 이런식으로 사용 가능

문자열클래스(521p)
    String : 문자열을 저장하고 조작할 때 사용
    StringBuilder : 효율적인 문자열 조작 기능이 필요할 때 사용
    StringTokenizer : 구분자로 연결된 문자열을 분리할 때 사용

String(522p)
    문자열 리터럴은 자동으로 String 객체로 생성되지만 다양한 생성자를 이용해 직접 객체 생성도 가능.

StringBuilder클래스(523p)
    String은 내부 문자열을 수정할 수 없음. 변수 += "111"은 객체를 수정하는게 아니라 새로운 String객체를 생성하는 것.
    효율이 좋지 않기 때문에 잦은 문자열 변경이 필요하다면 StringBuilder사용이 좋음.
    * 리턴타입 StringBuilder
        - append(기본값 | 문자열) : 문자열을 끝에 추가
        - insert(위치, 기본값 | 문자열) : 문자열을 지정 위치에 추가
        - delete(시작위치, 끝위치) : 문자열 일부 삭제
        - replace(시작위치, 끝위치, 문자열) : 문자열 일부 대체
    * 리턴타입 String
        - toString() : 완성된 문자열 리턴

StringTokenizer(525p)
    문자열이 구분자로 연결되어있을 경우 문자열을 분리하려면 split() 메소드나 StringTokenizer를 이용하면 됨.
    여러 종류의 구분자와 함께있는 데이터를 뽑아낼 떼는 split() + 정규식을 사용해야하지만, 구분자가 하나일 경우에는 tokenizer 쓰면 됨.
    * StringTokenizer 메소드
        - 리턴타입 int - countTokens() : 분리할 수 있는 문자열 총 수
        - 리턴타입 boolean - hasMoreTokens() : 남아있는 문자열이 있는지 여부
        - 리턴타입 String - nextToken() : 문자열을 하나씩 가져옴(더이상 가져올 문자열이 없으면 예외발생)

포장클래스(526p)
    자바는 기본타입을 갖는 객체를 생성할 수 있음. 이런 객체를 포장객체wrapper라고 함(값을 포장하고 있다는 뜻)
    포장객체는 포장하는 기본타입 값을 변경할 수 없고 단지 객체로 생성하는 데 목적이 있음.
    기본타입 값을 포장객체로 만드는 과정을 박싱이라하고, 포장객체->기본타입의 값을 얻어내는 과정을 언박싱이라고 함.
    - 박싱 : Integer obj = 100;
    - 언박싱 : int value = obj;

수학 클래스(530p)
    수학 계산에 사용할 수 있는 메소드 제공. 모든 클래스는 정적이므로 바로 사용 가능.
    - 절대값 : Math.abs();
    - 올림값 : Math.ceil();
    - 버림값 : Math.floor();
    - 최대값 : Math.max();
    - 최소값 : Math.min();
    - 랜덤값 : Math.random();
    - 반올림값 : Math.round();

날짜와 시간 클래스(534p)
    * 날짜/시간 클래스
        - Date : 날짜 정보를 전달
        - Calender : 다양한 시간대별로 날짜와 시간을 얻을 수 있음
        - LocalDateTime : 날짜와 시간을 조작할 때 사용