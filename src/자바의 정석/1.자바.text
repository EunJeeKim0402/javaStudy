자바란?(15p)
    썬 마이크로시스템즈에서 개발하여 1996년 1월 발표한 객체지향 프로그래밍 언어
    운영체제에 독립적이라는 특징.
    풍부한 클래스 라이브러리.

자바의 특징
    1. 운영체제에 독립적 : 일종의 에뮬레이터인 JVM을 통해서 가능.
    2. 객체지향 언어 : 객체지향의 특징인 상속, 캡슐화, 다형성이 잘 적용된 순수한 객체지향언어
    3. 배우기 쉬움 : C++과 스몰톡의 장점은 취하고 불필요한 부분은 과감히 제거했음
    4. 자동 메모리 관리 : 자바로 작성된 프로그램이 실행되면 가비지 컬렉터가 자동적으로 메모리를 관리해줌.
    5. 네트워크와 분산처리 지원 : 다양한 네트워크 프로그래밍 라이브러리로 네트워크 관련 프로그램 개발을 지원
    6. 멀티쓰레드를 지원 : 시스템과 관계없이 구현 가능, 관련된 라이브러리도 제공됨. 인터프리터가 여러 쓰레드에 대한 스케줄링을 담당
    7. 동적로딩을 지원 : 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용 가능.

JVM
    Java virtual machine. 자바를 실행하기 위한 가상 기계(컴퓨터).
    * 가상기계란 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어. ex.TV를 소프트웨어화한 윈도우 미디어 플레이어
    자바로 작성된 어플리케이션은 모두 이 JVM에서만 실행됨. 일반 어플리케이션 코드는 OS만 거치고 하드웨어로 가는 반면 java는 JVM을 한번 더 거치고
    하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시 해석되어 속도가 느림. JVM은 OS에 종속적이라 해당 OS의 JVM이 필요한

자바 개발도구(19p)
    JDK의 bin 디렉토리에 있는 주요 실행파일 특징
    javac.exe - 자바 컴파일러. 자바소스코드 -> 바이트코드로 컴파일
    * 바이트 코드 : JVM이 이해할 수 있는 기계어
    java.exe - 자바 인터프리터. 컴파일러가 생성한 바이트코드를 해석 및 실행
    javap.exe - 역어셈블러. 컴파일된 클래스를 원래 소스로 변환
    * JDK vs JRE : JDK = JRE+개발에 필요한 실행파일(javac.exe등) / JRE = JVM+클래스라이브러리

자바 API문서
    http://java.sun.com/

자바로 프로그램 작성하기(22p)
    클래스명과 파일명이 정확히(대소문자까지) 같아야됨. 클래스를 실행하려면 자바컴파일러(javac.exe)를 사용해서 소스파일로부터 클래스파일을 생성함.
    그 다음 자바인터프리터로 실행(java.exe)
    모든 클래스가 main메소드가 필요한건 아니지만, 하나의 java어플리케이션에는 main메소드를 포함한 클래스가 반드시 하나는 있어야됨.
    하나의 소스파일에 두개 이상의 클래스를 정의하는 것도 가능. 이럴 때 클래스파일은 클래스마나 하나씩 만들어짐.

자바 프로그램 실행과정
    1. 클래스파일 로드
    2. 클래스파일 검사(파일형식, 악성코드 체크 등)
    3. 지정된 클래스에서 main(String[] args)를 호출

주석 작성 방법
    // 한줄 주석
    /* */ 범위 주석
    이 주석은 javadoc.exe에 의해 html문서로 자동변환됨

변수란?
    단 하나의 값을 저장할 수 있는 메모리상의 공간. 
    int number;      // 정수형 변수 선언 방법
    int number = 10; // 정수형 변수를 선언하고 값을 초기화. 사용하기에 앞서 적절한 값을 저장해주는 것

변수의 타입
    크게 기본형과 참조형으로 나뉘어짐.
    기본형 : 실제 값을 저장. boolean / char / byte / short / int / long / float / double
    참조형 : 객체의 주소를 저장 / 8개의 기본형을 제외한 나머지 타입들
    Date today;     // 참조변수를 선언하는 방법. 타입이 클래스 이름인 것들은 모두 참조변수임

기본형 변수
    모두 8개의 자료형이 있으며 크게 논리형, 문자형, 정수형, 실수형 4가지로 나뉘어짐
    논리형을 제외한 7개 타입은 서로 변환이 가능하기 때문에 연산도 가능
    논리형 - boolean(1byte)
    문자형 - char(2byte)
    정수형 - byte(1byte) / short(2byte) / int(4byte) / long(8byte)
    실수형 - float(4byte) / double(8byte)

문자형 - char
    만일 어떤 문자의 유니코드를 알고 싶으면 char형 변수를 int형으로 변환하면 됨
    ex. 'A'의 유니코드는 '\u0041'인데 16진수 41은 10진수로 65임
    char의 모든 데이터는 숫자로 저장됨.
    영문자 이외 tab이나 backspace등의 특수문자는 이런식으로 저장하면 됨 '\t' , '\b'등...
    그리고 덧셈 연산자(+) 피연산자 중 어느 한 쪽이 String이면 나머지 한쪽을 먼저 String으로 변환한 다음 두 String을 결합함(boolean, null도 동일)

정수형 - byte, short, int, long
    크기순 : byte(1) < short(2) < int(4) < long(8)
    왠만하면 int형 사용을 권장. 연산 시 범위를 넘어서 잘못된 결과를 얻을 수도 있고, JVM의 피연산자 스택이 4byte로 변환해서 계산해서 효율성이 떨어짐
    long big = 100000000000000L; // long타입의 리터럴에는 접미사 L을 붙여야됨. 안붙이면 int타입으로 간주함
    * 리터럴? : 그 자체로 데이터인 것. 예를 들어 'A', "AB", 123은 리터럴임. 상수와 의미는 같지만 변경할 수 있다는 점에서 상수와 구분됨
    10진수 외 16진수나 8진수로 표현된 정수를 변수에 저장할 수도 있음. 16진수면 접두사 '0x'/'0X', 8진수는 '0'을 붙인다
    int octNumber = 010;    // 8진수 10, 10진수로는 8
    int hexNumber = 0x10;   // 16진수 10, 10진수로는 16

실수형 - float, double
    float형 변수는 접미사 f를 붙여야되고 double은 d를 생략 가능.
    float는 저장할 수 있는 범위가 넓으나 표현할 수 있는 자릿수에 한계가 있음. 정밀도가 필요할 경우 double권장...

형변환(캐스팅)
    변수 또는 리터럴 타입을 다른 타입으로 변환하는 것. 기본형과 참조형 사이에는 형변환이 성립되지 않음(JDK1.5부터는 가능하긴함)
    int score = (int)85.4;  // double -> int
    값의 표현범위가 작은 자료형 -> 큰 자료형은 캐스트 연산자 생략이 가능하지만, 반대는 캐스트 연산자를 반드시 작성해야됨(값손실때문)

연산자(57p)
    우선순위 높은 순서대로(위가 높은거)
    단항 연산자(연산방향 <--) : ++, --, +, -, ~, !
    산술 연산자(연산방향 -->) : *, /, %
                           +, -
                           <<, >>, >>>
    비교 연산자(연산방향 -->) : <, >, <=, >=, instanceof(인스턴스 타입 확인하는 연산자)
                           ==, !=
    논리 연산자(연산방향 -->) : $
                           ^
                           |
                           &&
                           ||
    삼항 연산자(연산방향 -->) : ?:
    대입 연산자(연산방향 <--) : =, *=, /=, %=, +=, -=, <<=, >>=, >>>=, &=, ^=, |=

단항 연산자 - 증감연산자 ++, --
    ++ -- 전위형 후위형 차이 : 값이 참조되기 전에 변화하냐, 참조 후에 변화하냐 차이
    (예를 들어, int i=5; j=i++; print(j,i)를 하면 5,6이 나옴. 증감되기 전의 5를 j에 넣어서 5가 출력되는 것)

단항 연산자 - 부호 연산자 +, -
    + : 피연산자에 양수 1 곱한 결과
    - : 피연산자에 음수 1 곱한 결과

단항 연산자 - 비트전환 연산자 ~
    정수형, char형에만 사용 가능. 
    피연산자를 2진수로 표현했을 때 0->1, 1->0로 바꿈(byte/short/char은 int로 변환된 뒤 전환됨)

단항 연산자 - 논리부정 연산자 !
    boolean형에만 사용 가능. true->false, false->true

산술 연산자 - 사칙 연산자 +, -, *, /
    산술연산자들은 크기가 4byte이하인 자료형을 int형으로 변환시키고 연산함. 
    그리고 피연산자의 타입을 자료형의 표현범위가 큰 쪽에 맞춰서 일치시킴.

산술 연산자 - 나머지 연산자 %
    왼쪽 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 돌려주는 연산자

산술 연산자 - 쉬프트 연산자 <<, >>, >>>
    비트값을 주어진 숫자만큼 이동시킴. 정수형 변수에만 사용 가능. 일반 연산자에비해 속도가 빠르다는 장점/가독성이 떨어진다는 단점
    피연산자의 각 자리(2진수로 표현했을 때)를 오른쪽 또는 왼쪽으로 옮김
    오른쪽으로 n자리를 이동 - 피연산자를 2n로 나눈 것과 같은 결과
    왼쪽으로 n자리를 이동  - 피연산자를 2n로 곱한 것과 같은 결과
    <<는 피연산자 부호에 상관없이 자리를 왼쪽으로 이동시키며 빈칸을 0으로 채움
    >>는 오른쪽으로 이동시키고 음수인 경우 빈자리를 1로 채우게 됨
    >>>는 부호에 상관없이 항상 0으로 빈자리를 채움

비교 연산자 - 대소비교 연산자 <, >, <=, >=
    두 피연산자의 크기를 비교

비교 연산자 - 등가비교 연산자 -, ==, !=

논리 연산자 - 논리 연산자 &&, ||
    피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만을 허용함

논리 연산자 - 비트 연산자 &, | ^
    이진 비트연산 수행. 실수형인 float와 double을 제외한 모든 기본형에 사용 가능
    |(OR)  - 피연산자 중 한쪽의 값이 1이면 1을 결과로 얻음. 그외는 0
    &(AND) - 피연산자 중 양쪽이 모두 1이어야 1을 결과로 얻음. 그외는 0
    ^(XOR) - 피연산자의 값이 서로 다를 때만 1을 결과로 얻음. 같을 때는 0

그 외 연산자 - 삼항 연산자 ? :
    (조건식) ? 식1 : 식2
    조건식의 연산결과가 참이면 식1을 결과로 얻고 거짓이면 식2를 결과로 얻음

그 외 연산자 - 대입연산자 = op=
    대입연산자는 변수에 값 또는 수식의 연산결과를 저장하는 데 사용됨. 모든 연산자 중 가장 낮은 연산순위를 가짐
    op=는 +=, -=, /= 이런걸 얘기하는것임



* 참고
    [+1와 ++의 차이]
    c + 1은 c의 값을 변화시키지 않고 단순히 계산 결과를 반환
    c++는 c의 값을 변화시키고, 그 변화된 값은 이후 연산에서 유지됨

* 예시 문제풀이
38p
public class CharToCode {
    public static void main(String[] args) {
        char ch = 'A'; // '\u0041';로 바꿔써도 같음
        int code = (int)ch; // ch의 값을 int형으로 변환해서 저장

        System.out.println(ch); // 'A'
        System.out.println(code); // 65
    }
}

41p
public class StringTest {
    public static void main(String[] args) {
        String a = 7 + " ";
        String b = " " + 7;
        String c = 7 + "";
        String d = "" + 7;
        String e = "" + "";
        String f = 7 + 7 + "";
        String g = "" + 7 + 7 ;

        System.out.println(a); // 7
        System.out.println(b); //  7
        System.out.println(c); // 7
        System.out.println(d); // 7
        System.out.println(e); //
        System.out.println(f); // 14. int 연산 먼저 하고 String으로 전환되는듯
        System.out.println(g); // 77
    }
}

43p
public class ByteOverFlow {
    public static void main(String[] args) {
        byte b = 0;
        int i = 0;

        for(int x=0; x<=270; x++) {
            System.out.println(b++);
            System.out.println('\t'); // tab출력
            System.out.println(i++); // byte 최대값인 127을 넙어 이후에는 -128... 다시 0부터 시작
        }
    }
}

46p
public class PrecisionTest {
    public static void main(String[] args) {
        float f = 1.2345678901234567890f;
        double d = 1.2345678901234567890;
        float f2 = 0.100000001f;
        double d2 = 0.100000001;
        double d3 = 0.1000000000000001;

        System.out.println(f); // 1.2345679 끝자리에서 반올림됨
        System.out.println(d); // 1.2345678901234567
        System.out.println(f2); // 0.1 float가 표현할 수 있는 가수의 자리수(정밀도)를 넘어섰기때문
        System.out.println(d2); // 0.100000001
        System.out.println(d3); // 0.1000000000000001
    }
}


public class SpecialChar {
    public static void main(String[] args) {
        char single = '\'';
        String dblQuote = "\"Hello\"";
        String root = "c:\\";

        System.out.println(single); // '
        System.out.println(dblQuote); // "Hello"
        System.out.println(root); // c:\
    }
}


87p
public class Main {
    public static void main(String[] args) {
        int x = 2;
        int y = 5;
        char c = 'A'; // 아스키코드 65

        System.out.println(1 + x << 33); // 6. <<는 비트연산자로 비트 값을 주어진 숫자만큼 이동시킴
        System.out.println(y>=5 || x<0 && x>2); // true
        System.out.println(y+=10 - x++); // 13
        System.out.println(x+=2); // 5... 이전 줄에서 x++했기 때문임
        System.out.println( !('A'<=c && c<='Z') ); // false
        System.out.println('C'-c); // 2
        System.out.println('5'-'0'); // 5. 아스키코드로 각자 '5'는 53, '0'은 48이기 때문
        System.out.println(c+1); // 66
        System.out.println(++c); // B
        System.out.println(c++); // B
    }
}