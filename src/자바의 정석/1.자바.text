자바란?(15p)
    썬 마이크로시스템즈에서 개발하여 1996년 1월 발표한 객체지향 프로그래밍 언어
    운영체제에 독립적이라는 특징.
    풍부한 클래스 라이브러리.

자바의 특징
    1. 운영체제에 독립적 : 일종의 에뮬레이터인 JVM을 통해서 가능.
    2. 객체지향 언어 : 객체지향의 특징인 상속, 캡슐화, 다형성이 잘 적용된 순수한 객체지향언어
    3. 배우기 쉬움 : C++과 스몰톡의 장점은 취하고 불필요한 부분은 과감히 제거했음
    4. 자동 메모리 관리 : 자바로 작성된 프로그램이 실행되면 가비지 컬렉터가 자동적으로 메모리를 관리해줌.
    5. 네트워크와 분산처리 지원 : 다양한 네트워크 프로그래밍 라이브러리로 네트워크 관련 프로그램 개발을 지원
    6. 멀티쓰레드를 지원 : 시스템과 관계없이 구현 가능, 관련된 라이브러리도 제공됨. 인터프리터가 여러 쓰레드에 대한 스케줄링을 담당
    7. 동적로딩을 지원 : 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용 가능.

JVM
    Java virtual machine. 자바를 실행하기 위한 가상 기계(컴퓨터).
    * 가상기계란 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어. ex.TV를 소프트웨어화한 윈도우 미디어 플레이어
    자바로 작성된 어플리케이션은 모두 이 JVM에서만 실행됨. 일반 어플리케이션 코드는 OS만 거치고 하드웨어로 가는 반면 java는 JVM을 한번 더 거치고
    하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시 해석되어 속도가 느림. JVM은 OS에 종속적이라 해당 OS의 JVM이 필요한

자바 개발도구(19p)
    JDK의 bin 디렉토리에 있는 주요 실행파일 특징
    javac.exe - 자바 컴파일러. 자바소스코드 -> 바이트코드로 컴파일
    * 바이트 코드 : JVM이 이해할 수 있는 기계어
    java.exe - 자바 인터프리터. 컴파일러가 생성한 바이트코드를 해석 및 실행
    javap.exe - 역어셈블러. 컴파일된 클래스를 원래 소스로 변환
    * JDK vs JRE : JDK = JRE+개발에 필요한 실행파일(javac.exe등) / JRE = JVM+클래스라이브러리

자바 API문서
    http://java.sun.com/

자바로 프로그램 작성하기(22p)
    클래스명과 파일명이 정확히(대소문자까지) 같아야됨. 클래스를 실행하려면 자바컴파일러(javac.exe)를 사용해서 소스파일로부터 클래스파일을 생성함.
    그 다음 자바인터프리터로 실행(java.exe)
    모든 클래스가 main메소드가 필요한건 아니지만, 하나의 java어플리케이션에는 main메소드를 포함한 클래스가 반드시 하나는 있어야됨.
    하나의 소스파일에 두개 이상의 클래스를 정의하는 것도 가능. 이럴 때 클래스파일은 클래스마나 하나씩 만들어짐.

자바 프로그램 실행과정
    1. 클래스파일 로드
    2. 클래스파일 검사(파일형식, 악성코드 체크 등)
    3. 지정된 클래스에서 main(String[] args)를 호출

주석 작성 방법
    // 한줄 주석
    /* */ 범위 주석
    이 주석은 javadoc.exe에 의해 html문서로 자동변환됨

변수란?
    단 하나의 값을 저장할 수 있는 메모리상의 공간. 
    int number;      // 정수형 변수 선언 방법
    int number = 10; // 정수형 변수를 선언하고 값을 초기화. 사용하기에 앞서 적절한 값을 저장해주는 것

변수의 타입
    크게 기본형과 참조형으로 나뉘어짐.
    기본형 : 실제 값을 저장. boolean / char / byte / short / int / long / float / double
    참조형 : 객체의 주소를 저장 / 8개의 기본형을 제외한 나머지 타입들
    Date today;     // 참조변수를 선언하는 방법. 타입이 클래스 이름인 것들은 모두 참조변수임

기본형 변수
    모두 8개의 자료형이 있으며 크게 논리형, 문자형, 정수형, 실수형 4가지로 나뉘어짐
    논리형을 제외한 7개 타입은 서로 변환이 가능하기 때문에 연산도 가능
    논리형 - boolean(1byte)
    문자형 - char(2byte)
    정수형 - byte(1byte) / short(2byte) / int(4byte) / long(8byte)
    실수형 - float(4byte) / double(8byte)

문자형 - char
    만일 어떤 문자의 유니코드를 알고 싶으면 char형 변수를 int형으로 변환하면 됨
    ex. 'A'의 유니코드는 '\u0041'인데 16진수 41은 10진수로 65임
    char의 모든 데이터는 숫자로 저장됨.
    영문자 이외 tab이나 backspace등의 특수문자는 이런식으로 저장하면 됨 '\t' , '\b'등...
    그리고 덧셈 연산자(+) 피연산자 중 어느 한 쪽이 String이면 나머지 한쪽을 먼저 String으로 변환한 다음 두 String을 결합함(boolean, null도 동일)

정수형 - byte, short, int, long
    크기순 : byte(1) < short(2) < int(4) < long(8)
    왠만하면 int형 사용을 권장. 연산 시 범위를 넘어서 잘못된 결과를 얻을 수도 있고, JVM의 피연산자 스택이 4byte로 변환해서 계산해서 효율성이 떨어짐
    long big = 100000000000000L; // long타입의 리터럴에는 접미사 L을 붙여야됨. 안붙이면 int타입으로 간주함
    * 리터럴? : 그 자체로 데이터인 것. 예를 들어 'A', "AB", 123은 리터럴임. 상수와 의미는 같지만 변경할 수 있다는 점에서 상수와 구분됨
    10진수 외 16진수나 8진수로 표현된 정수를 변수에 저장할 수도 있음. 16진수면 접두사 '0x'/'0X', 8진수는 '0'을 붙인다
    int octNumber = 010;    // 8진수 10, 10진수로는 8
    int hexNumber = 0x10;   // 16진수 10, 10진수로는 16

실수형 - float, double
    float형 변수는 접미사 f를 붙여야되고 double은 d를 생략 가능.
    float는 저장할 수 있는 범위가 넓으나 표현할 수 있는 자릿수에 한계가 있음. 정밀도가 필요할 경우 double권장...

형변환(캐스팅)
    변수 또는 리터럴 타입을 다른 타입으로 변환하는 것. 기본형과 참조형 사이에는 형변환이 성립되지 않음(JDK1.5부터는 가능하긴함)
    int score = (int)85.4;  // double -> int
    값의 표현범위가 작은 자료형 -> 큰 자료형은 캐스트 연산자 생략이 가능하지만, 반대는 캐스트 연산자를 반드시 작성해야됨(값손실때문)

연산자(57p)
    우선순위 높은 순서대로(위가 높은거)
    단항 연산자(연산방향 <--) : ++, --, +, -, ~, !
    산술 연산자(연산방향 -->) : *, /, %
                           +, -
                           <<, >>, >>>
    비교 연산자(연산방향 -->) : <, >, <=, >=, instanceof(인스턴스 타입 확인하는 연산자)
                           ==, !=
    논리 연산자(연산방향 -->) : $
                           ^
                           |
                           &&
                           ||
    삼항 연산자(연산방향 -->) : ?:
    대입 연산자(연산방향 <--) : =, *=, /=, %=, +=, -=, <<=, >>=, >>>=, &=, ^=, |=

단항 연산자 - 증감연산자 ++, --
    ++ -- 전위형 후위형 차이 : 값이 참조되기 전에 변화하냐, 참조 후에 변화하냐 차이
    (예를 들어, int i=5; j=i++; print(j,i)를 하면 5,6이 나옴. 증감되기 전의 5를 j에 넣어서 5가 출력되는 것)

단항 연산자 - 부호 연산자 +, -
    + : 피연산자에 양수 1 곱한 결과
    - : 피연산자에 음수 1 곱한 결과

단항 연산자 - 비트전환 연산자 ~
    정수형, char형에만 사용 가능. 
    피연산자를 2진수로 표현했을 때 0->1, 1->0로 바꿈(byte/short/char은 int로 변환된 뒤 전환됨)

단항 연산자 - 논리부정 연산자 !
    boolean형에만 사용 가능. true->false, false->true

산술 연산자 - 사칙 연산자 +, -, *, /
    산술연산자들은 크기가 4byte이하인 자료형을 int형으로 변환시키고 연산함. 
    그리고 피연산자의 타입을 자료형의 표현범위가 큰 쪽에 맞춰서 일치시킴.

산술 연산자 - 나머지 연산자 %
    왼쪽 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 돌려주는 연산자

산술 연산자 - 쉬프트 연산자 <<, >>, >>>
    비트값을 주어진 숫자만큼 이동시킴. 정수형 변수에만 사용 가능. 일반 연산자에비해 속도가 빠르다는 장점/가독성이 떨어진다는 단점
    피연산자의 각 자리(2진수로 표현했을 때)를 오른쪽 또는 왼쪽으로 옮김
    오른쪽으로 n자리를 이동 - 피연산자를 2n로 나눈 것과 같은 결과
    왼쪽으로 n자리를 이동  - 피연산자를 2n로 곱한 것과 같은 결과
    <<는 피연산자 부호에 상관없이 자리를 왼쪽으로 이동시키며 빈칸을 0으로 채움
    >>는 오른쪽으로 이동시키고 음수인 경우 빈자리를 1로 채우게 됨
    >>>는 부호에 상관없이 항상 0으로 빈자리를 채움

비교 연산자 - 대소비교 연산자 <, >, <=, >=
    두 피연산자의 크기를 비교

비교 연산자 - 등가비교 연산자 -, ==, !=

논리 연산자 - 논리 연산자 &&, ||
    피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만을 허용함

논리 연산자 - 비트 연산자 &, | ^
    이진 비트연산 수행. 실수형인 float와 double을 제외한 모든 기본형에 사용 가능
    |(OR)  - 피연산자 중 한쪽의 값이 1이면 1을 결과로 얻음. 그외는 0
    &(AND) - 피연산자 중 양쪽이 모두 1이어야 1을 결과로 얻음. 그외는 0
    ^(XOR) - 피연산자의 값이 서로 다를 때만 1을 결과로 얻음. 같을 때는 0

그 외 연산자 - 삼항 연산자 ? :
    (조건식) ? 식1 : 식2
    조건식의 연산결과가 참이면 식1을 결과로 얻고 거짓이면 식2를 결과로 얻음

그 외 연산자 - 대입연산자 = op=
    대입연산자는 변수에 값 또는 수식의 연산결과를 저장하는 데 사용됨. 모든 연산자 중 가장 낮은 연산순위를 가짐
    op=는 +=, -=, /= 이런걸 얘기하는것임

if문(93p)
    if(조건식) {
        // 조건식이 true일 때 수행될 문장
    } else if(조건식2) {
        // 조건식2가 true일 때 수행될 문장
    } else {
        // 조건식이 false일 때 수행될 문장
    }

중첩 if문
    if(조건식) {
        // 조건식이 true일 때 수행될 문장
        if(조건식2) {
            // 조건식2가 true일 때 수행될 문장
        } else {
            // 조건식1이 true고 조건식 2가 false일 때 수행될 문장
        }
    } else {
        // 조건식이 false일 때 수행될 문장
    }

switch문(98p)
    조건의 경우의 수가 많을때는 if문보다 나을 수 있음.
    연산결과가 int형 범위의 정수값이어야 한다(byte, short, char 등도 가능). 변수는 허락되지 않음.
    만약 break;가 없으면 switch문의 블럭 끝까지 모든 문장을 수행하게 됨.
    조건식 안에 (score/10) 이런식으로 계산식을 사용할 수도 있음.
    switch(조건식) {
        case 값1 :
            // 조건식 결과가 값1과 같을 때 수행될 문장들
            break;
        case 값2 :
            // 조건식 결과가 값2와 같을 때 수행될 문장들
            break;
        case 값1 :
            // 조건식 결과가 일치하는 case문이 없을 경우 수행될 문장들
    }

반복문 - for, while, do-while(106p)
    while문과 do-while문은 기본적인 구조는 같으나 do-while문은 최소한 한번은 수행을 보장.
    Loop1 : for~와 같이 for문에 이름을 붙일 수도 있음(break Loop1 이런식으로 사용).
    for(초기화; 조건식; 증감식) {
        // 조건식이 true일 때 수행될 문장
    }

    while(조건식) {
        // 조건식이 true일 때 수행될 문장
    }

    do {
        // 조건식이 true일 때 수행될 문장
    } while(조건식);

break문(116p)
    가장 가까운 switch문 or 반복문을 벗어나는 데 사용됨.

continue문
    반복이 진행되는 동안 continue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어감.
    break문과는 달리 반복문 전체를 벗어나지 않고 다음 반복을 수행.

배열?(127p)
    같은 타입의 여러 변수를 하나의 묶음으로 다루는 것. for문과 같이 사용하면 효율이 좋음
    타입[] 변수이름;
    타입 변수이름[]; // 아래 위 둘 다 사용해서 선언 가능
    int[] score; // 배열을 선언 -> 생성된 배열을 다루는 데 사용될 참조변수 선언
    score = new int[5]; // 배열을 생성 -> 값을 저장할 수 있는 공간 생성(예시는 기본값 0으로 다 초기화된 상태)

다차원 배열(139p)
    자바는 2차원 이상의 다차원 배열도 허용함(잘 사용되지는 않음).
    선언방법1 : 타입[][] 변수이름;
    선언방법2 : 타입 변수이름[][];
    선언방법3 : 타입[] 변수이름[];
    예를 들어 5행 3열의 테이블 변수 생성하는 방법 int[][] score = new int[5][3];

가변 배열(142p)
    보다 자유로운 형태의 배열. 2차원 이상의 다차원 배열을 생성할 때 전체 배열 차수 중 마지막 차수의 크기를 지정하지 않고 
    추후에 각기 다른 크기의 배열을 생성해서 유동적인 가변 배열을 구성하는 것.

배열 복사
    arraycopy()나 for문 사용 가능. 

객체지향언어?(161p)
    실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.
    1. 코드의 재사용성이 높다
    2. 코드의 관리가 용이하다 : 코드간의 관계를 이용해서 적은 노력으로 쉽게 변경 가능
    3. 신뢰성이 높은 프로그래밍을 가능하게 한다 : 제어자와 메소드를 이용해서 데이터를 보호, 올바른 값 유지. 코드 중복 제거 - 오동작 방지

클래스(162p)
    클래스란 객체를 정의해 놓은 것(혹은 객체의 설계도 또는 틀). 객체를 생성하는 데 사용됨. 
    변수 : 하나의 데이터를 저장할 수 있는 공간
    배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
    구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
    클래스 : 데이터와 함수의 결합(구조체 + 함수)

객체와 인스턴스
    클래스로부터 객체를 만드는 과정을 인스턴스화라고 함. 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함.
    즉 객체=인스턴스 이지만 객체는 모든 인스턴스를 대표하는 포괄적인 의미. 인스턴스는 보다 구체적인 의미.
    속성 : 멤버변수, 특성, 필드, 상태
    기능 : 메소드, 행위, 함수
    클래스명 변수명;
    변수명 = new 클래스명();

변수(177p)
        변수의 종류    |    선언위치    |        생성시기    
    -------------------------------------------------------
         클래스변수    |   클래스영역    |  클래스가 메모리에 올라갈 때
        인스턴스변수   |   클래스영역    |  인스턴스가 생성되었을 때
          지역변수    | 클래스영역 외 영역|  변수 선언문이 수행되었을 때
                (메소드,생성자,초기화 블럭 내부)
    
    인스턴스변수 : 클래스 영역에 생성되며, 클래스의 인스턴스를 생성할 때 만들어짐. 인스턴스는 독립적인 저장공간을 가져 서로 다른 값 가질 수 있음
    클래스변수 : 선언하려면 인스턴스변수 앞에 static을 붙이기만 하면 됨. 클래스변수는 보든 인스턴스가 공통된 저장공간을 공유하게 됨.
              그래서 클래스변수를 공유변수라고도 함. 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 클래스변수로 선언
              인스턴스변수는 인스턴스를 생성한 후 사용가능하지만 클래스변수는 인스턴스 없이도 언제라도 바로 사용 가능
              클래스가 로딩될 때 생성되어 프로그램이 종료될 때까지 유지. 클래스이름.클래스변수(ex. TV.remocon)
    지역변수 : 메소드 내에 선언되어 메소드 내에서만 사용 가능, 메소드가 종료되면 소멸됨. 블럭{}을 벗어나면 소멸되어 사용불가.

메소드(180p)
    어떤 작업을 수행하기 위한 명령문의 집합. 주로 어떤 값을 입력받아서 처리하고 그 결과를 반환.
    반복적으로 사용되는 코드를 줄이기 위해 사용.
    - 하나의 메소드는 한가지 기능만 수행하도록 작성
    - 반복적으로 수행되어야하는 여러 문장을 하나의 메소드로 정의하면 좋음
    - 관련된 여러 문장을 하나의 메소드로 만드는게 좋음
    호출방법 : 참조변수.메소드이름(값1, 값2...); // ex. mm.add(a, b); // MyMath mm = new MyMath();

return문(182p)
    return을 사용하면 현재 실행 중인 메소드를 종료하고 호출한 메소드로 되돌아가게 함. 반환 값이 있는 경우 반환값 지정해야됨.
    반환값이 있는 경우, 메소드 선언부에 정의된 반환타입과 일치하거나 반환타입으로 자동형변환이 가능한 것이어야됨.
    * return값이 없는 메소드의 경우 매개변수에 담아서 return없이도 반환할 수 있음

JVM의 메모리구조(187p) // Java virtual machine. 자바를 실행하기 위한 가상 기계(컴퓨터).
    JVM은 메모리를 용도에 따라 여러 영역으로 나누어서 관리함. 크게 Method Area, Call stack, Heap으로 나뉘어짐.
    -------------------------------그림----------------------------------
    Method Area - 클래스데이터[cv], 클래스데이터, 클래스데이터... // cv는 클래스변수
    Call Stack - main[lv] // lv는 지역변수
    Heap - 인스턴스[iv], 인스턴스, 인스턴스... // iv는 인스턴스변수는
    --------------------------------------------------------------------
    메소드영역 : 프로그램 실행 중 어떤 클래스가 사용되면 JVM은 해당 클래스의 클래스파일을 읽어 분석하여 클래스정보(클래스데이터)를 저장함.
              이 때 클래스변수도 이 영역에 함께 생성됨
    힙       : 인스턴스가 생성되는 공간(프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성됨).
    호출스택  :  call stack 또는 execution stack. 작업에 필요한 메모리 공간 제공.
               메소드가 호출되면, 호출스택에 호출된 메소드를 위한 메모리가 할당되고, 이 메모리는 작업 수행동안 지역변수(매개변수 포함)
               들과 연산의 중간결과 등을 저장하는 데 사용됨. 메소드 작업 종료하면 할당되었던 메모리공간은 반환되어 비워짐
               - 메소드가 호출되면 수행에 필요한만큼의 메모리를 스택에 할당받음
               - 메소드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거됨
               - 호출스택의 제일 위에 있는 메소드가 현재 실행중인 메소드
               - 아래에 있는 메소드가 바로 위의 메소드를 호출한 메소드

기본형 매개변수 vs 참조형 매개변수(190p)
    기본형 : read only
    참조형 : read & write
    메소드를 호출할 때 매개변수로 지정한 값을 메소드의 매개변수에 복사해서 넘겨줌.
    매개변수 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스 주소가 복사됨.
    즉, 기본형은 저장된 값만 얻지만, 참조형으로 선언하면 값 변경까지 가능.

재귀호출(192p)
    메소드 내부에서 자기 자신을 다시 호출하는 것.

클래스메소드(static메소드)와 인스턴스메소드(195p)
    1. 클래스 설계 시, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙임
    2. 클래스변수는 인스턴스 생성 없이도 사용 가능 // ex.'클래스이름.메소드이름(매개변수)'
    3. 클래스메소드는 인스턴스변수를 사용할 수 없음.
    4. 메소드 내에서 인스턴스변수를 사용하지 않는다면 static 붙이는걸 권장
    * 멤버변수 : 클래스변수 + 인스턴스변수

클래스멤버와 인스턴스멤버 간의 참조와 호출(197p)
    같은 클래스 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조&호출 가능.
    단 클래스멤버가 인스턴스멤버를 참조&호출하고자 하는 경우에는 인스턴스를 생성해야됨.
    왜냐하면 인스턴스멤버가 존재하는 시점에 클래스멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스멤버가 존재할수도, 아닐수도 있기때문.

메소드 오버로딩(199p)
    보통은 메소드가 구별되어야하기 때문에 각기 다른 이름을 가져야함. 그러나 같은 이름/매개변수 개수&타입이 다르면 정의할 수 있음.
    overloading의 사전적 의미는 '과적하다' 즉 많이 싣는 것. 아래와 같은 조건이 필요.(순서가 다를 경우도 오버로딩으로 간주)
    - 메소드 이름이 같아야됨
    - 매개변수의 개수 또는 타입이 달라야됨
    - 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않음
    * 오버로딩의 장점
    - 하나의 이름이니 같은 기능을 한다고 예측할 수 있음
    - 메소드 이름을 절약할 수 있음
    
생성자(204p)
    생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드. 
    따라서 인스턴스 변수의 초기화 작업에 주로 사용되고, 인스턴스 생성 시 실행되어야 할 작업을 위해서도 사용됨. 리턴값이 없음

    Card c = new Card();
    1. 연산자 new에 의해 메모리(heap)에 Card클래스의 인스턴스가 생성됨
    2. 생성자 Card()가 호출되어 수행됨
    3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장됨
    즉, 지금까지 인스턴스를 생성하기 위해 사용해왔던 클래스이름()이 바로 생성자였던 것. 반드시 생성자 중 하나를 선택해서 지정해야됨
    사실 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어있어야해서 만들어줘야하지만 기본생성자가 자동으로 만들어짐(컴파일러에서)

    생성자도 메소드처럼 매개변수를 선언해서 호출할 수 있음.
    예를 들어, 인스턴스를 생성할 때 Car()를 사용한다면 인스턴스들을 생성 후 따로 초기화해줘야하지만 매개변수가 있다면 생성과동시에 원하는값으로 초기화 가능.

생성자에서 다른 생성자 호출하기 - this(), this (208p)
    다음 두 조건을 만족시키면 생성자 간에도 서로 호출 가능
    - 생성자의 이름으로 클래스이름 대신 this를 사용
    - 한 생성자에서 닫른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능
    this는 참조변수로 인스턴스 자신을 가리킴. this를 사용할 수 있는 건 인스턴스멤버뿐. 
    static메소드에서는 인스턴스멤버를 못쓰는것처럼 this도 못씀(static 메소드가 호출된 시점에 인스턴스가 존재하지 않을 수도 있기 때문)
    - this : 인스턴스 자기 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어있음. 모든 인스턴스변수에 지역변수로 숨겨진 채로 존재
    - this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용

생성자를 이용한 인스턴스 복사(211p)
    Car(Car c) {
        color = c.color;
        gearType = c.gearType;
        door = c.door;
    }
    위 예시는 Car클래스의 참조변수를 매개변수로 선언한 생성자. 매개변수로 넘겨진 참조변수가 가리키는 Car인스턴스 값을 인스턴스 자신으로 복사하는 것.



* 참고
    [+1와 ++의 차이]
    c + 1은 c의 값을 변화시키지 않고 단순히 계산 결과를 반환
    c++는 c의 값을 변화시키고, 그 변화된 값은 이후 연산에서 유지됨



--------------------------------------------------------------------------------------------------------------------

* 메소드
charAt(int idx) : 문자열중에 idx 위치에 있는 문자를 반환
JOptionPane.showInputDialog : 입력창에서 입력받기