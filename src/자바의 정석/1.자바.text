자바란?(15p)
    썬 마이크로시스템즈에서 개발하여 1996년 1월 발표한 객체지향 프로그래밍 언어
    운영체제에 독립적이라는 특징.
    풍부한 클래스 라이브러리.

자바의 특징
    1. 운영체제에 독립적 : 일종의 에뮬레이터인 JVM을 통해서 가능.
    2. 객체지향 언어 : 객체지향의 특징인 상속, 캡슐화, 다형성이 잘 적용된 순수한 객체지향언어
    3. 배우기 쉬움 : C++과 스몰톡의 장점은 취하고 불필요한 부분은 과감히 제거했음
    4. 자동 메모리 관리 : 자바로 작성된 프로그램이 실행되면 가비지 컬렉터가 자동적으로 메모리를 관리해줌.
    5. 네트워크와 분산처리 지원 : 다양한 네트워크 프로그래밍 라이브러리로 네트워크 관련 프로그램 개발을 지원
    6. 멀티쓰레드를 지원 : 시스템과 관계없이 구현 가능, 관련된 라이브러리도 제공됨. 인터프리터가 여러 쓰레드에 대한 스케줄링을 담당
    7. 동적로딩을 지원 : 실행 시 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용 가능.

JVM
    Java virtual machine. 자바를 실행하기 위한 가상 기계(컴퓨터).
    * 가상기계란 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어. ex.TV를 소프트웨어화한 윈도우 미디어 플레이어
    자바로 작성된 어플리케이션은 모두 이 JVM에서만 실행됨. 일반 어플리케이션 코드는 OS만 거치고 하드웨어로 가는 반면 java는 JVM을 한번 더 거치고
    하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시 해석되어 속도가 느림. JVM은 OS에 종속적이라 해당 OS의 JVM이 필요한

자바 개발도구(19p)
    JDK의 bin 디렉토리에 있는 주요 실행파일 특징
    javac.exe - 자바 컴파일러. 자바소스코드 -> 바이트코드로 컴파일
    * 바이트 코드 : JVM이 이해할 수 있는 기계어
    java.exe - 자바 인터프리터. 컴파일러가 생성한 바이트코드를 해석 및 실행
    javap.exe - 역어셈블러. 컴파일된 클래스를 원래 소스로 변환
    * JDK vs JRE : JDK = JRE+개발에 필요한 실행파일(javac.exe등) / JRE = JVM+클래스라이브러리

자바 API문서
    http://java.sun.com/

자바로 프로그램 작성하기(22p)
    클래스명과 파일명이 정확히(대소문자까지) 같아야됨. 클래스를 실행하려면 자바컴파일러(javac.exe)를 사용해서 소스파일로부터 클래스파일을 생성함.
    그 다음 자바인터프리터로 실행(java.exe)
    모든 클래스가 main메소드가 필요한건 아니지만, 하나의 java어플리케이션에는 main메소드를 포함한 클래스가 반드시 하나는 있어야됨.
    하나의 소스파일에 두개 이상의 클래스를 정의하는 것도 가능. 이럴 때 클래스파일은 클래스마나 하나씩 만들어짐.

자바 프로그램 실행과정
    1. 클래스파일 로드
    2. 클래스파일 검사(파일형식, 악성코드 체크 등)
    3. 지정된 클래스에서 main(String[] args)를 호출

주석 작성 방법
    // 한줄 주석
    /* */ 범위 주석
    이 주석은 javadoc.exe에 의해 html문서로 자동변환됨

변수란?
    단 하나의 값을 저장할 수 있는 메모리상의 공간. 
    int number;      // 정수형 변수 선언 방법
    int number = 10; // 정수형 변수를 선언하고 값을 초기화. 사용하기에 앞서 적절한 값을 저장해주는 것

변수의 타입
    크게 기본형과 참조형으로 나뉘어짐.
    기본형 : 실제 값을 저장. boolean / char / byte / short / int / long / float / double
    참조형 : 객체의 주소를 저장 / 8개의 기본형을 제외한 나머지 타입들
    Date today;     // 참조변수를 선언하는 방법. 타입이 클래스 이름인 것들은 모두 참조변수임

기본형 변수
    모두 8개의 자료형이 있으며 크게 논리형, 문자형, 정수형, 실수형 4가지로 나뉘어짐
    논리형을 제외한 7개 타입은 서로 변환이 가능하기 때문에 연산도 가능
    논리형 - boolean(1byte)
    문자형 - char(2byte)
    정수형 - byte(1byte) / short(2byte) / int(4byte) / long(8byte)
    실수형 - float(4byte) / double(8byte)

문자형 - char
    만일 어떤 문자의 유니코드를 알고 싶으면 char형 변수를 int형으로 변환하면 됨
    ex. 'A'의 유니코드는 '\u0041'인데 16진수 41은 10진수로 65임
    char의 모든 데이터는 숫자로 저장됨.
    영문자 이외 tab이나 backspace등의 특수문자는 이런식으로 저장하면 됨 '\t' , '\b'등...
    그리고 덧셈 연산자(+) 피연산자 중 어느 한 쪽이 String이면 나머지 한쪽을 먼저 String으로 변환한 다음 두 String을 결합함(boolean, null도 동일)

정수형 - byte, short, int, long
    크기순 : byte(1) < short(2) < int(4) < long(8)
    왠만하면 int형 사용을 권장. 연산 시 범위를 넘어서 잘못된 결과를 얻을 수도 있고, JVM의 피연산자 스택이 4byte로 변환해서 계산해서 효율성이 떨어짐
    long big = 100000000000000L; // long타입의 리터럴에는 접미사 L을 붙여야됨. 안붙이면 int타입으로 간주함
    * 리터럴? : 그 자체로 데이터인 것. 예를 들어 'A', "AB", 123은 리터럴임. 상수와 의미는 같지만 변경할 수 있다는 점에서 상수와 구분됨
    10진수 외 16진수나 8진수로 표현된 정수를 변수에 저장할 수도 있음. 16진수면 접두사 '0x'/'0X', 8진수는 '0'을 붙인다
    int octNumber = 010;    // 8진수 10, 10진수로는 8
    int hexNumber = 0x10;   // 16진수 10, 10진수로는 16

실수형 - float, double
    float형 변수는 접미사 f를 붙여야되고 double은 d를 생략 가능.
    float는 저장할 수 있는 범위가 넓으나 표현할 수 있는 자릿수에 한계가 있음. 정밀도가 필요할 경우 double권장...

형변환(캐스팅)
    변수 또는 리터럴 타입을 다른 타입으로 변환하는 것. 기본형과 참조형 사이에는 형변환이 성립되지 않음(JDK1.5부터는 가능하긴함)
    int score = (int)85.4;  // double -> int
    값의 표현범위가 작은 자료형 -> 큰 자료형은 캐스트 연산자 생략이 가능하지만, 반대는 캐스트 연산자를 반드시 작성해야됨(값손실때문)

연산자(57p)
    우선순위 높은 순서대로(위가 높은거)
    단항 연산자(연산방향 <--) : ++, --, +, -, ~, !
    산술 연산자(연산방향 -->) : *, /, %
                           +, -
                           <<, >>, >>>
    비교 연산자(연산방향 -->) : <, >, <=, >=, instanceof(인스턴스 타입 확인하는 연산자)
                           ==, !=
    논리 연산자(연산방향 -->) : $
                           ^
                           |
                           &&
                           ||
    삼항 연산자(연산방향 -->) : ?:
    대입 연산자(연산방향 <--) : =, *=, /=, %=, +=, -=, <<=, >>=, >>>=, &=, ^=, |=

단항 연산자 - 증감연산자 ++, --
    ++ -- 전위형 후위형 차이 : 값이 참조되기 전에 변화하냐, 참조 후에 변화하냐 차이
    (예를 들어, int i=5; j=i++; print(j,i)를 하면 5,6이 나옴. 증감되기 전의 5를 j에 넣어서 5가 출력되는 것)

단항 연산자 - 부호 연산자 +, -
    + : 피연산자에 양수 1 곱한 결과
    - : 피연산자에 음수 1 곱한 결과

단항 연산자 - 비트전환 연산자 ~
    정수형, char형에만 사용 가능. 
    피연산자를 2진수로 표현했을 때 0->1, 1->0로 바꿈(byte/short/char은 int로 변환된 뒤 전환됨)

단항 연산자 - 논리부정 연산자 !
    boolean형에만 사용 가능. true->false, false->true

산술 연산자 - 사칙 연산자 +, -, *, /
    산술연산자들은 크기가 4byte이하인 자료형을 int형으로 변환시키고 연산함. 
    그리고 피연산자의 타입을 자료형의 표현범위가 큰 쪽에 맞춰서 일치시킴.

산술 연산자 - 나머지 연산자 %
    왼쪽 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 돌려주는 연산자

산술 연산자 - 쉬프트 연산자 <<, >>, >>>
    비트값을 주어진 숫자만큼 이동시킴. 정수형 변수에만 사용 가능. 일반 연산자에비해 속도가 빠르다는 장점/가독성이 떨어진다는 단점
    피연산자의 각 자리(2진수로 표현했을 때)를 오른쪽 또는 왼쪽으로 옮김
    오른쪽으로 n자리를 이동 - 피연산자를 2n로 나눈 것과 같은 결과
    왼쪽으로 n자리를 이동  - 피연산자를 2n로 곱한 것과 같은 결과
    <<는 피연산자 부호에 상관없이 자리를 왼쪽으로 이동시키며 빈칸을 0으로 채움
    >>는 오른쪽으로 이동시키고 음수인 경우 빈자리를 1로 채우게 됨
    >>>는 부호에 상관없이 항상 0으로 빈자리를 채움

비교 연산자 - 대소비교 연산자 <, >, <=, >=
    두 피연산자의 크기를 비교

비교 연산자 - 등가비교 연산자 -, ==, !=

논리 연산자 - 논리 연산자 &&, ||
    피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만을 허용함

논리 연산자 - 비트 연산자 &, | ^
    이진 비트연산 수행. 실수형인 float와 double을 제외한 모든 기본형에 사용 가능
    |(OR)  - 피연산자 중 한쪽의 값이 1이면 1을 결과로 얻음. 그외는 0
    &(AND) - 피연산자 중 양쪽이 모두 1이어야 1을 결과로 얻음. 그외는 0
    ^(XOR) - 피연산자의 값이 서로 다를 때만 1을 결과로 얻음. 같을 때는 0

그 외 연산자 - 삼항 연산자 ? :
    (조건식) ? 식1 : 식2
    조건식의 연산결과가 참이면 식1을 결과로 얻고 거짓이면 식2를 결과로 얻음

그 외 연산자 - 대입연산자 = op=
    대입연산자는 변수에 값 또는 수식의 연산결과를 저장하는 데 사용됨. 모든 연산자 중 가장 낮은 연산순위를 가짐
    op=는 +=, -=, /= 이런걸 얘기하는것임

if문(93p)
    if(조건식) {
        // 조건식이 true일 때 수행될 문장
    } else if(조건식2) {
        // 조건식2가 true일 때 수행될 문장
    } else {
        // 조건식이 false일 때 수행될 문장
    }

중첩 if문
    if(조건식) {
        // 조건식이 true일 때 수행될 문장
        if(조건식2) {
            // 조건식2가 true일 때 수행될 문장
        } else {
            // 조건식1이 true고 조건식 2가 false일 때 수행될 문장
        }
    } else {
        // 조건식이 false일 때 수행될 문장
    }

switch문(98p)
    조건의 경우의 수가 많을때는 if문보다 나을 수 있음.
    연산결과가 int형 범위의 정수값이어야 한다(byte, short, char 등도 가능). 변수는 허락되지 않음.
    만약 break;가 없으면 switch문의 블럭 끝까지 모든 문장을 수행하게 됨.
    조건식 안에 (score/10) 이런식으로 계산식을 사용할 수도 있음.
    switch(조건식) {
        case 값1 :
            // 조건식 결과가 값1과 같을 때 수행될 문장들
            break;
        case 값2 :
            // 조건식 결과가 값2와 같을 때 수행될 문장들
            break;
        case 값1 :
            // 조건식 결과가 일치하는 case문이 없을 경우 수행될 문장들
    }

반복문 - for, while, do-while(106p)
    while문과 do-while문은 기본적인 구조는 같으나 do-while문은 최소한 한번은 수행을 보장.
    Loop1 : for~와 같이 for문에 이름을 붙일 수도 있음(break Loop1 이런식으로 사용).
    for(초기화; 조건식; 증감식) {
        // 조건식이 true일 때 수행될 문장
    }

    while(조건식) {
        // 조건식이 true일 때 수행될 문장
    }

    do {
        // 조건식이 true일 때 수행될 문장
    } while(조건식);

break문(116p)
    가장 가까운 switch문 or 반복문을 벗어나는 데 사용됨.

continue문
    반복이 진행되는 동안 continue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어감.
    break문과는 달리 반복문 전체를 벗어나지 않고 다음 반복을 수행.

배열?(127p)
    같은 타입의 여러 변수를 하나의 묶음으로 다루는 것. for문과 같이 사용하면 효율이 좋음
    타입[] 변수이름;
    타입 변수이름[]; // 아래 위 둘 다 사용해서 선언 가능
    int[] score; // 배열을 선언 -> 생성된 배열을 다루는 데 사용될 참조변수 선언
    score = new int[5]; // 배열을 생성 -> 값을 저장할 수 있는 공간 생성(예시는 기본값 0으로 다 초기화된 상태)

다차원 배열(139p)
    자바는 2차원 이상의 다차원 배열도 허용함(잘 사용되지는 않음).
    선언방법1 : 타입[][] 변수이름;
    선언방법2 : 타입 변수이름[][];
    선언방법3 : 타입[] 변수이름[];
    예를 들어 5행 3열의 테이블 변수 생성하는 방법 int[][] score = new int[5][3];

가변 배열(142p)
    보다 자유로운 형태의 배열. 2차원 이상의 다차원 배열을 생성할 때 전체 배열 차수 중 마지막 차수의 크기를 지정하지 않고 
    추후에 각기 다른 크기의 배열을 생성해서 유동적인 가변 배열을 구성하는 것.

배열 복사
    arraycopy()나 for문 사용 가능. 

객체지향언어?(161p)
    실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.
    1. 코드의 재사용성이 높다
    2. 코드의 관리가 용이하다 : 코드간의 관계를 이용해서 적은 노력으로 쉽게 변경 가능
    3. 신뢰성이 높은 프로그래밍을 가능하게 한다 : 제어자와 메소드를 이용해서 데이터를 보호, 올바른 값 유지. 코드 중복 제거 - 오동작 방지

클래스(162p)
    클래스란 객체를 정의해 놓은 것(혹은 객체의 설계도 또는 틀). 객체를 생성하는 데 사용됨. 
    변수 : 하나의 데이터를 저장할 수 있는 공간
    배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
    구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
    클래스 : 데이터와 함수의 결합(구조체 + 함수)

객체와 인스턴스
    클래스로부터 객체를 만드는 과정을 인스턴스화라고 함. 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함.
    즉 객체=인스턴스 이지만 객체는 모든 인스턴스를 대표하는 포괄적인 의미. 인스턴스는 보다 구체적인 의미.
    속성 : 멤버변수, 특성, 필드, 상태
    기능 : 메소드, 행위, 함수
    클래스명 변수명;
    변수명 = new 클래스명();

변수(177p)
        변수의 종류    |    선언위치    |        생성시기    
    -------------------------------------------------------
         클래스변수    |   클래스영역    |  클래스가 메모리에 올라갈 때
        인스턴스변수   |   클래스영역    |  인스턴스가 생성되었을 때
          지역변수    | 클래스영역 외 영역|  변수 선언문이 수행되었을 때
                (메소드,생성자,초기화 블럭 내부)
    
    인스턴스변수 : 클래스 영역에 생성되며, 클래스의 인스턴스를 생성할 때 만들어짐. 인스턴스는 독립적인 저장공간을 가져 서로 다른 값 가질 수 있음
    클래스변수 : 선언하려면 인스턴스변수 앞에 static을 붙이기만 하면 됨. 클래스변수는 보든 인스턴스가 공통된 저장공간을 공유하게 됨.
              그래서 클래스변수를 공유변수라고도 함. 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 클래스변수로 선언
              인스턴스변수는 인스턴스를 생성한 후 사용가능하지만 클래스변수는 인스턴스 없이도 언제라도 바로 사용 가능
              클래스가 로딩될 때 생성되어 프로그램이 종료될 때까지 유지. 클래스이름.클래스변수(ex. TV.remocon)
    지역변수 : 메소드 내에 선언되어 메소드 내에서만 사용 가능, 메소드가 종료되면 소멸됨. 블럭{}을 벗어나면 소멸되어 사용불가.
    
    public class varExam {
        int instanceVariable; //인스턴스변수
        static int classVariable; //클래스변수 (static변수, 공유변수)
        void method(){
            int localVariable; //지역변수
        }
    }

메소드(180p)
    어떤 작업을 수행하기 위한 명령문의 집합. 주로 어떤 값을 입력받아서 처리하고 그 결과를 반환.
    반복적으로 사용되는 코드를 줄이기 위해 사용.
    - 하나의 메소드는 한가지 기능만 수행하도록 작성
    - 반복적으로 수행되어야하는 여러 문장을 하나의 메소드로 정의하면 좋음
    - 관련된 여러 문장을 하나의 메소드로 만드는게 좋음
    호출방법 : 참조변수.메소드이름(값1, 값2...); // ex. mm.add(a, b); // MyMath mm = new MyMath();

return문(182p)
    return을 사용하면 현재 실행 중인 메소드를 종료하고 호출한 메소드로 되돌아가게 함. 반환 값이 있는 경우 반환값 지정해야됨.
    반환값이 있는 경우, 메소드 선언부에 정의된 반환타입과 일치하거나 반환타입으로 자동형변환이 가능한 것이어야됨.
    * return값이 없는 메소드의 경우 매개변수에 담아서 return없이도 반환할 수 있음

JVM의 메모리구조(187p) // Java virtual machine. 자바를 실행하기 위한 가상 기계(컴퓨터).
    JVM은 메모리를 용도에 따라 여러 영역으로 나누어서 관리함. 크게 Method Area, Call stack, Heap으로 나뉘어짐.
    -------------------------------그림----------------------------------
    Method Area - 클래스데이터[cv], 클래스데이터, 클래스데이터... // cv는 클래스변수
    Call Stack - main[lv] // lv는 지역변수
    Heap - 인스턴스[iv], 인스턴스, 인스턴스... // iv는 인스턴스변수는
    --------------------------------------------------------------------
    메소드영역 : 프로그램 실행 중 어떤 클래스가 사용되면 JVM은 해당 클래스의 클래스파일을 읽어 분석하여 클래스정보(클래스데이터)를 저장함.
              이 때 클래스변수도 이 영역에 함께 생성됨
    힙       : 인스턴스가 생성되는 공간(프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성됨).
    호출스택  :  call stack 또는 execution stack. 작업에 필요한 메모리 공간 제공.
               메소드가 호출되면, 호출스택에 호출된 메소드를 위한 메모리가 할당되고, 이 메모리는 작업 수행동안 지역변수(매개변수 포함)
               들과 연산의 중간결과 등을 저장하는 데 사용됨. 메소드 작업 종료하면 할당되었던 메모리공간은 반환되어 비워짐
               - 메소드가 호출되면 수행에 필요한만큼의 메모리를 스택에 할당받음
               - 메소드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거됨
               - 호출스택의 제일 위에 있는 메소드가 현재 실행중인 메소드
               - 아래에 있는 메소드가 바로 위의 메소드를 호출한 메소드

기본형 매개변수 vs 참조형 매개변수(190p)
    기본형 : read only
    참조형 : read & write
    메소드를 호출할 때 매개변수로 지정한 값을 메소드의 매개변수에 복사해서 넘겨줌.
    매개변수 타입이 기본형일 때는 기본형 값이 복사되지만, 참조형이면 인스턴스 주소가 복사됨.
    즉, 기본형은 저장된 값만 얻지만, 참조형으로 선언하면 값 변경까지 가능.

재귀호출(192p)
    메소드 내부에서 자기 자신을 다시 호출하는 것.

클래스메소드(static메소드)와 인스턴스메소드(195p)
    1. 클래스 설계 시, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙임
    2. 클래스변수는 인스턴스 생성 없이도 사용 가능 // ex.'클래스이름.메소드이름(매개변수)'
    3. 클래스메소드는 인스턴스변수를 사용할 수 없음.
    4. 메소드 내에서 인스턴스변수를 사용하지 않는다면 static 붙이는걸 권장
    * 멤버변수 : 클래스변수 + 인스턴스변수

클래스멤버와 인스턴스멤버 간의 참조와 호출(197p)
    같은 클래스 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조&호출 가능.
    단 클래스멤버가 인스턴스멤버를 참조&호출하고자 하는 경우에는 인스턴스를 생성해야됨.
    왜냐하면 인스턴스멤버가 존재하는 시점에 클래스멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스멤버가 존재할수도, 아닐수도 있기때문.

메소드 오버로딩(199p)
    보통은 메소드가 구별되어야하기 때문에 각기 다른 이름을 가져야함. 그러나 같은 이름/매개변수 개수&타입이 다르면 정의할 수 있음.
    overloading의 사전적 의미는 '과적하다' 즉 많이 싣는 것. 아래와 같은 조건이 필요.(순서가 다를 경우도 오버로딩으로 간주)
    - 메소드 이름이 같아야됨
    - 매개변수의 개수 또는 타입이 달라야됨
    - 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않음
    * 오버로딩의 장점
    - 하나의 이름이니 같은 기능을 한다고 예측할 수 있음
    - 메소드 이름을 절약할 수 있음
    
생성자(204p)
    생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드. 
    따라서 인스턴스 변수의 초기화 작업에 주로 사용되고, 인스턴스 생성 시 실행되어야 할 작업을 위해서도 사용됨. 리턴값이 없음

    Card c = new Card();
    1. 연산자 new에 의해 메모리(heap)에 Card클래스의 인스턴스가 생성됨
    2. 생성자 Card()가 호출되어 수행됨
    3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장됨
    즉, 지금까지 인스턴스를 생성하기 위해 사용해왔던 클래스이름()이 바로 생성자였던 것. 반드시 생성자 중 하나를 선택해서 지정해야됨
    사실 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어있어야해서 만들어줘야하지만 기본생성자가 자동으로 만들어짐(컴파일러에서)

    생성자도 메소드처럼 매개변수를 선언해서 호출할 수 있음.
    예를 들어, 인스턴스를 생성할 때 Car()를 사용한다면 인스턴스들을 생성 후 따로 초기화해줘야하지만 매개변수가 있다면 생성과동시에 원하는값으로 초기화 가능.

생성자에서 다른 생성자 호출하기 - this(), this (208p)
    다음 두 조건을 만족시키면 생성자 간에도 서로 호출 가능
    - 생성자의 이름으로 클래스이름 대신 this를 사용
    - 한 생성자에서 닫른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능
    this는 참조변수로 인스턴스 자신을 가리킴. this를 사용할 수 있는 건 인스턴스멤버뿐. 
    static메소드에서는 인스턴스멤버를 못쓰는것처럼 this도 못씀(static 메소드가 호출된 시점에 인스턴스가 존재하지 않을 수도 있기 때문)
    - this : 인스턴스 자기 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어있음. 모든 인스턴스변수에 지역변수로 숨겨진 채로 존재
    - this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용

생성자를 이용한 인스턴스 복사(211p)
    Car(Car c) {
        color = c.color;
        gearType = c.gearType;
        door = c.door;
    }
    위 예시는 Car클래스의 참조변수를 매개변수로 선언한 생성자. 매개변수로 넘겨진 참조변수가 가리키는 Car인스턴스 값을 인스턴스 자신으로 복사하는 것.

변수의 초기화(213p)
    변수의 초기화는 선택적이지만 가능하면 선언과 동시에 적절한 값으로 초기화하는걸 권장.
    멤버변수는 자동적으로 자료형에 맞는 기본값으로 초기화가 이루어지지만 지역변수는 사용하기 전에 반드시 초기화를 해야됨.
    지역변수는 int i = 0;과 같이 하면 되나 멤버변수의 초기화 방법은 아래와 같음.
    1. 명시적 초기화(explicit initialization) - 변수를 선언과 동시에 초기화하는 것을 명시적 초기화라고 함. //int door = 4;
    2. 생성자(constructor)
    3. 초기화 블럭(initialization block)
        - 인스턴스 초기화 블럭 : 인스턴스변수를 초기화하는 데 사용
        - 클래스 초기화 블럭 : 클래스변수를 초기화하는 데 사용

초기화 블럭(215p)
    - 인스턴스 초기화 블럭 : 단순히 클래스 내에 블럭{}을 만들고 그 안에 코드를 작성하면 됨.
    - 클래스 초기화 블럭 : 인스턴스 초기화 블럭 앞에 단순히 static을 덧붙이면 됨.
    claa InitBlock {
        static { ~~클래스 초기화 블럭~~ }
        { ~~인스턴스 초기화 블럭~~ }
    }
    클래스 초기화 블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되고 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행됨.
    인스턴스변수의 초기화는 주로 생성자를 사용해서 인스턴스 초기화 블럭은 잘 사용되지 않음.
    다만 클래스의 모든 생성자에서 공통적으로 수행되어져야하는 코드가 있는 경우 사용하면 좋음.
    * 생성자보다 인스턴스 초기화 블럭이 먼저 수행됨

멤버변수의 초기화 시기와 순서(218p)
    - 클래스변수의 초기화 시점  : 클래스가 처음 로딩될 때 단 한번 초기화
    - 인스턴스변수의 초기화 시점 : 인스턴스가 생성될 때 마다 각 인스턴스별로 초기화가 이루어짐

    - 클래스변수의 초기화 순서  : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
    - 인스턴스변수의 초기화 순서 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자

상속(235p)
    상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것.
    상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 클래스를 작성하고, 코드를 공통적으로 관리할 수 있음.
    class Child extends Parent {
        // Parent(조상클래스)를 상속받는 <---- Child(자식클래스) 작성
    }
    - 조상클래스 : 부모클래스, 상위(super)클래스, 기반(base)클래스
    - 자손클래스 : 자식클래스, 하위(sub)클래스, 파생된(derived)클래스
    부모클래스에 변수를 추가하면 자손클래스에서는 자동으로 그 변수를 생성한것과 같음. 그러나 자식에서 추가하면 조상클래스는 아무런 영향X

    - 생성자와 초기화블럭은 상속되지 않음. 멤버만 상속됨
    - 자손클래스의 멤버 갯수는 조상클래스보다 항상 같거나 많다
    만약 Child2가 생겨도 자식 클래스 간에는 아무런 관계가 없음. 자식클래스 간에 공통으로 추가해야된다면 부모클래스에 추가하는게 나음.

클래스간의 관계 - 포함관계(241p)
    상속 이외에도 클래스를 재사용하는 방법이 있는데 '포함'관계를 맺어주는 것임. 한 클래스의 멤버변수로 다른 클래스를 선언하는 것을 뜻함.
    class Circle {
        Point c = new Point(); // int x; int y; 포함된 클래스
        int r;
    }
    
클래스간의 관계 결정하기(242p)
    상속관계 : ~은 ~이다
    포함관계 : ~은 ~을 가지고 있다.

단일상속(248p)
    자바는 하나의 클래스만 상속받을 수 있음. (extends TV~)

Object클래스(250p)
    모든 클래스의 조상. 다른 클래스로부터 상속받지 않는 모든 클래스들은 자동적으로 상속받게됨.
    (이미 어떤 클래스로부터 상속받도록 작성된 클래스는 extends Object가 추가되지 않음)
    덕분에 자바의 모든 클래스는 Object클래스의 멤버들을 상속받아 사용할 수 있음(toString(), equals()등...)

오버라이딩(251p)
    조상클래스로부터 상속받은 메소드 내용을 변경하는걸 오버라이딩이라고 함. 
    - 오버라이딩의 조건 : 이름이 같아야됨 / 매개변수가 같아야됨 / 리턴타입이 같아야됨
    1. 접근제어자는 조상클래스의 메소드보다 좁은 범위로 변경할 수 없다.
    2. 조상클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.
    3. 인스턴스메소드를 static메소드로 또는 그 반대로 변경할 수 없다.

오버로딩 vs 오버라이딩(253p)
    오버로딩 : 기존에 없는 새로운 메소드를 정의하는 것(new)
    오버라이딩 : 상속받은 메소드의 내용을 변경하는 것(modify)
    class Parent {
        void parentMethod() {}
    }    
    class Child extends Parent {
        void parentMethod() {}      // 오버라이딩
        void parentMethod(int i) {} // 오버로딩
         
        void childMethod() {}
        void childMethod(int i) {}  // 오버로딩
        void childMethod() {}       // 에러. 중복정의되어있음(Child)
    }

super(254p)
    super는 자손클래스에서 조상클래스로부터 상속받은 멤버를 참조하는 데 사용되는 참조변수.
    멤버변수와 지역변수의 이름이 같을 때 this로 구분하듯이, 상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을 때는 super를 사용해서 구별.
    조상클래스로부터 상속받은 멤버도 자손클래스 자신의 멤버이므로 super대신 this를 사용할 수 있음. 서로 구별해야하는 경우에만 super를 사용하는게 좋음.
    조상의 멤버와 자신의 멤버를 구별하는 데 사용된다는 점을 제외하고는 super는 this와 근본적으로 같음. this처럼 super 역시 인스턴스메소드에서만 사용 가능

super()(256p)
    조상클래스의 생성자. this()와 마찬가지로 생성자임.
    Object클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자를 호출해야됨(같은 클래스의 다른 생성자 or 조상의 생성자).
    그러지않으면 컴파일러가 자동적으로 super();를 생성자의 첫 줄에 삽입.
    즉, 조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되도록 해야 함.

패키지(260p)
    패키지란 클래스의 묶음. 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스를 묶어놓고 효율적으로 관리 가능.
    클래스의 실제 이름은 패키지명을 포함한 것임. 즉, 같은 이름의 클래스더라도 서로 다른 패키지면 구별이 가능.
    - 하나의 소스파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용
    - 모든 클래스는 반드시 하나의 패키지에 속해야됨(지금까지 패키지 지정없이도 에러나지 않은 이유는 자동으로 unnamed package에 속했기때문)
    - 패키지는 . 을 구분자로하여 계층구조로 구성 가능
    - 패키지는 물리적으로 클래스파일을 포함하는 하나의 디렉토리
    package 패키지명; 으로 선언 가능. 소문자 권장(클래스와 구분하기 위함).

import문(264p)
    클래스 코드 작성 전 import문으로 사용하고자하는 클래스의 패키지를 미리 명시해주면 패키지명 생략 가능.
    import java.util.Date; 이렇게도 쓸 수 있고 import java.util.*; 이렇게도 사용 가능.

제어자(modifier)(267p)
    제어자는 클래스, 변수 또는 메소드의 선언부에 함께 사용되어 부가적인 의미를 부여함.
    제어자는 클래스나 멤버변수와 메소드에 주로 사용되며, 하나의 대상에 대해 여러 제어자를 조합하여 사용하는 것이 가능.
    단, 접근제어자는 한번에 네가지 중 하나만 선택해서 사용할 수 있음.
    접근제어자   - public, protected, default, private
    그 외 제어자 - static, final, abstract, native, transient, synchronized, volatile, strictfp

static(267p)
    클래스의, 공통적인 이라는 의미. 클래스변수는 인스턴스와 관계없이 같은 값을 가짐(하나의 변수를 모든 인스턴스가 공유하기 때문).
    static이 사용될 수 있는 곳
    - 멤버변수 : 모든 인스턴스에 공통적으로 사용되는 클래스변수. 클래스가 메모리에 로드될 때 생성됨
    - 메소드 : 인스턴스 생성 없이도 호출이 가능한 static메소드가 됨. static메소드 내에서는 인스턴스멤버 직접 사용 불가.
    - 초기화 블럭
    class StaticTest {
        static int width = 200;     // 클래스변수
        static int height = 120;    // 클래스변수

        static {                    // 클래스 초기화 블럭
            // static변수의 복잡한 초기화 수행
        }

        static int max(int a, int b) { // 클래스메소드
            return a > b ? a : b;
        }
    }

final(268p)
    마지막의, 변경될 수 없는 이라는 의미. 거의 모든 대상에 사용 가능(클래스, 메소드, 멤버변수, 지역변수).
    변수에 사용되면 값을 변경할 수 없는 '상수'가 됨.
    클래스 : 변경될 수 없고 확장될 수 없는 클래스가 됨. 즉, 다른 클래스의 조상이 될 수 없음.
    메소드 : 변경될 수 없는 메소드. 오버라이딩을 통해 재정의될 수 없음.
    멤버변수, 지역변수 : 변수 앞에 final이 붙으면 값을 변경할 수 없는 상수가 됨(상수 변수는 대문자로 작성 권장)

생성자를 이용한 final 멤버변수 초기화(269p)
    final 변수는 상수이므로 일반적으로 선언과 동시에 초기화. 그러나 인스턴스변수의 경우 생성자에서 초기화 가능.
    클래스 내 매개변수를 갖는 생성자를 선언하여, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는 데 필요한 값을 생성자의 매개변수로부터 제공받음.
    이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능(ex.개개인별로 카드번호 값 변경)
    class Card {
        final int NUMBER;
        final String KIND;
        Card(String kind, int num) {
            KIND = kind; // 매개변수로 넘겨받은 값으로 KIND와 NUMBER 초기화
            NUMBER = num; 
        }
        Card() {
            this("HEART", 1);
        }
    }

abstract(270p)
    추상의, 미완성의. 메소드 선언부만 작성하고 실제 수행내용은 구현하지 않는 추상메소드를 선언하는 데 사용됨.
    클래스 : 클래스 내 추상메소드가 선언되어있음을 의미함
    메소드 : 선언부만 작성하고 구현부는 작성하지 않은 추상메소드임을 알림
    abstract class AbstractTest { // 추상클래스(추상메소드를 포함한 클래스)
        abstract void move(); // 추상메소드(구현부가 없는 메소드)
    }

접근제어자(271p)
    해당하는 요소를 외부에서 접근하지 못하도록 제한함. 멤버 또는 클래스에 사용됨(클래스, 멤버변수, 메소드, 생성자 사용가능)
    private : 같은 클래스 내에서만 접근 가능
    default : 같은 패키지 내에서만 접근 가능(기본값)
    protected : 같은 패키지 내, 그리고 다른 패키지의 자손클래스에서 접근 가능
    public : 접근제한X
    (public > protected > default > private 접근범위가 넓은쪽에서부터 좁은쪽까지 나열)

    사용가능한 접근제어자
    클래스         : public, (default)
    메소드, 멤버변수 : public, protected, (default), private
    지역변수       : 없음

접근제어자를 이용한 캡슐화(272p)
    클래스나 멤버에 접근제어자를 사용하는 이유는 외부로부터 클래스 내부에 선언된 데이터를 보호하기 위함. 즉 캡슐화
    또 다른 이유는 클래스 내에서만 사용되는 임시사용 멤버변수나 부분작업 관련 메소드 등의 멤버들을 클래스 내부에 감추기 위함임(복잡성 감소).
    private 객체에 접근하기 위해 getter/setter를 사용. get~은 단순히 멤버변수의 값을 반환/set~은 조건에 맞는 값일때만 멤버변수 값 변경.

생성자의 접근제어자(275p)
    생성자에 접근제어자를 사용함으로써 인스턴스 생성을 제한할 수 있음. 보통은 클래스의 접근제어자와 같지만 다르게 지정 가능.
    class Singleton {
        private static Singleton s = new Singleton(); // 인스턴스가 미리 생성되어야하므로 static이어야됨
        private Singleton() {
            // ...
        }
        // ...
    }

제어자의 조합(277p)
    대상에 따른 사용가능한 제어자
    클래스 : public, (default), final, abstract
    메소드 : 모든접근제어자, final, abstract, static
    멤버변수 : 모든접근제어자, final, static
    지역변수 : final

다형성(278p)
    여러가지 형태를 가질 수 있는 능력을 의미. 
    자바에서는 한 타입의 참조변수로 여러 타입 객체를 참조할 수 있도록 함(조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함)
    예시) TV클래스와 자손클래스인 CaptionTV클래스가 있음. 
         TV t = new CaptionTv(); // 가능. 부모 자신을 사용하는것보다 더 많은 메소드를 사용할 수 있음. 반대는 불가.

참조변수의 형변환(281p)
    기본변수처럼 참조변수도 형변환이 가능. 단 서로 상속관계에 있는 클래스 사이에서만 가능(자손<->조상). 
    그러나 참조변수가 참조하고있는 인스턴스의 자손타입으로 형변환하는 것은 허용되지 않음.
    자손타입 -> 조상타입(up-casting) : 형변환 생략가능
    자손타입 <- 조상타입(down-casting) : 형변환 생략불가

instanceof연산자(286p)
    참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용. 주로 조건문에 사용.
    instanceof 왼쪽에는 참조변수, 오른쪽에는 타입(클래스명)이 피연산자로 위치. 결과로 true/false(true=참조변수가 검사한 타입으로 형변환 가능)
    if(c instanceof FireEngine) { ... }
    
--------------------------------------288p부터는 꼭 필요한부분부터 작성중....

추상클래스 - abstract class(301p)
    클래스가 설계도라면 추상클래스는 미완성 설계도. 클래스가 미완성이라는 뜻은 미완성 메소드(추상메소드)를 포함하고 있다는 뜻.
    미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없음. 상속을 통해 자손에 의해서만 완성 가능.
    abstract class Class1 { ... }
    추상클래스는 추상메소드를 포함하고 있는 것을 제외하고는 일반클래스와 전혀 다르지 않음(생성자/멤버변수/메소드 다있음)
    * 다만 추상메소드가 없더라도 abstract로 지정해버리면 추상클래스이기때문에 클래스의 인스턴스를 생성할 수 없음.

추상메소드(302p)
    메소드는 선언부와 구현부(몸통)으로 구성되어있는데 구현부는 작성하지 않은 채로 남겨둔 것이 추상메소드. 즉 설계만 해놓고 수행내용은 없는 것.
    추상화 : 클래스 간의 공통점을 찾아내어 공통의 조상을 만드는 작업
    구체화 : 상속을 통해 클래스를 구현, 확장하는 작업
    abstract class Player { // 추상클래스
        abstract void play(int pos); // 추상메소드
        abstract void stop(); // 추상메소드
    }
    class AudioPlayer extends Player {
        void play(int pos) { /* 내용생략 */ } // 추상메소드 구현
        void stop() { /* 내용생략 */ } // 추상메소드 구현
    }
    abstract class AbstractPlayer extends Player {
        void play(int pos) { /* 내용생략 */ } // 추상메소드 구현
    }

인터페이스(307p)
    일종의 추상클래스. 오직 추상메소드와 상수만을 멤버로 가질 수 있음. 몸통을 가진 일반메소드나 멤버변수 불가.
    추상클래스를 '부분적으로만 완성된 미완성 설계도'라고 한다면 인터페이스는 '밑그림만 그려져있는 기본설계도'.
    interface 인터페이스이름 {
        public static final 타입 상수이름 = 값;
        public abstract 메소드이름(매개변수들...);
    }
    - 모든 멤버변수는 public static final이어야하고 생략 가능.
    - 모든 메소드는 public abstract이어야하고 생략 가능.
    인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속이 가능.
    interface Fightable extends Movable, Attrackable { }
    * 인터페이스 장점 - 개발시간 단축 / 표준화 가능 / 서로 관계없는 클래스 관계맺기 가능 / 독립적인 프로그래밍 가능
    * 인터페이스의 이해 - 클래스를 사용하는 쪽과 제공하는 쪽이 있음 / 메소드를 사용하는쪽에서는 사용하려는 메소드의 선언부만 알면 됨(내용은몰라도됨)


인터페이스의 구현 - implements(308p)
    class 클래스이름 implements 인터페이스이름 {
        // 인터페이스에 정의된 추상클래스 구현
    }
    extends implements를 동시에 사용하는것도 가능.

예외처리(343p)
    에러 - 프로그램 코드에 의해 수습될 수 없는 심각한 오류
    예외 - 프로그램 코드에 의해 수습될 수 있는 다소 미약한 오류

예외처리구문(344p)
    try {
        // 예외가 발생할 가능성이 있는 문장들을 넣음
    } catch(Exception1 e1) {
        // Exception1이 발생했을 경우 처리하는 문장
    } catch(ExceptionN eN) {
        // 위와동일
    }

try-catch문에서의 흐름(347p)
    try블럭 내에서 예외가 발생한 경우 -> 1. 발생한 예외와 일치하는 catch블럭 찾음 2. 블럭 내 문장을 수행 - catch문 빠져나가서 다음문장 수행.
    try블럭 내에서 예외가 발생하지 않은 경우 -> catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속함

finally블럭(358p)
    try {
        // 예외가 발생할 가능성이 있는 문장들을 넣음
    } catch(Exception1 e1) {
        // Exception1이 발생했을 경우 처리하는 문장
    } finally {
        // 예외 발생여부에 관계없이 항상 수행되어야하는 문장들. 맨 마지막에 위치해야 함.
    }

Object클래스(379p)
    java.lang패키지는 자바 프로그래밍에 가장 기본이 되는 클래스들을 포함하고 있음. 따라서 이 패키지는 import없이도 사용 가능. 그중 Object먼저.
    Object클래스는 모든 클래스의 최고 조상. 아래 다양한 메소드들 예시.
    - equals : 매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 boolean값으로 알려줌. 주소값으로 비교하기때문에 값이 같아도 false 가능.
    - hashCode : 해싱기법에 사용되는 해시함수를 구현한 것. 찾고자하는 값을 입력하면 그 값이 저장된 위치를 알려주는 해시코드를 반환함.
    * 해시코드? : 객체를 식별하기위한 integer값
    - toString : 인스턴스에 대한 정보를 문자열로 제공할 목적으로 정의한 것.
    - clone : 자신을 복제하여 새로운 인스턴스를 생성.

String클래스(389p)
    문자열을 저장하기위해 문자형 배열 변수(char[])value를 인스턴스 변수로 정의하고 있음. 크기가 0인 배열도 존재할 수 있음.

StringBuffer클래스(402p)
    String클래스는 인스턴스 생성 시 지정된 문자열을 변경할 수 없지만 StringBuffer클래스는 가능.

Math클래스(408p)
    기본적인 수학계산에 유용한 메소드로 구성되어있음.
    - random : 임의의 수를 얻을 수 있음
    - round : 반올림
    - abs : 절대값 반환(ex.10.0 -> 10)
    - cail : 올림 반환
    - floor : 버림 반환
    - max : 두 값을 비교하여 큰 쪽을 반환
    - min : 두 값을 비교하여 작은 쪽을 반환
    - rint : 주어진 double값과 가장 가까운 정수값을 double형으로 반환

wrapper클래스(410p)
    기본형 변수도 때로는 객체로 다루어져야하는 경우 사용. 8개의 기본형을 대표하는 8개의 wrapper클래스가 있음.
    ex) Integer i = new Integer(100);

Number클래스(415p)
    추상클래스로 내부적으로 숫자를 멤버변수로 갖는 클래스들의 조상. 그 아래 Byte, Integer등이 있는것.

내부클래스(427p)
    클래스 내에 선언된 클래스. 클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계이기 때문.
    - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
    - 코드의 복잡성을 줄일 수 있다(캡슐화)

내부클래스의 종류와 특징(428p)
    선언 위치에 따라 아래와 같이 구분되어짐.
    - 인스턴스 클래스 : 외부클래스의 멤버변수 선언위치에 선언하고 외부클래스의 인스턴스 멤버처럼 다루어짐.
                    주로 외부클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언됨.
    - 스태틱 클래스   : 외부클래스의 멤버변수 선언위치에 선언하고 외부클래스의 static멤버처럼 다루어짐.
                     주로 외부클래스의 static멤버, 특히 static메소드에서 사용될 목적으로 선언됨.
    - 지역 클래스    : 외부클래스의 메소드나 초기화블럭 안에서 선언하고 선언된 영역 내부에서만 사용 가능.
    - 익명 클래스    : 클래스의 선언과 객체의 생성을 동시에하는 이름없는 클래스(일회용)

내부클래스의 제어자와 접근성(429p)
    인스턴스클래스와 스태틱클래스는 외부클래스의 멤버변수와 같은 위치에 선언되고, 같은 성질을 가짐.
    따라서 내부클래스가 외부클래스의 멤버와 같이 간주되고, 인스턴스멤버와 static멤버간의 규칙이 내부클래스에서도 똑같이 적용됨.
    내부클래스도 abstract나 final과 같은 제어자를 사용할 수 있고, private, protected같은 접근제어자도 사용 가능.
    다만 내부클래스 중 스태틱클래스만 static멤버를 가질 수 있음. final과 static이 동시에 붙은 변수는 모든 내부클래스에서 정의 가능.

익명클래스(434p)
    클래스의 선언과 객체생성을 동시에 하기 때문에 일회성으로만 사용 가능. 오직 하나의 객체만 생성.
    new 조상클래스이름() {
        // 멤버선언
    }
    new 구현인터페이스이름() {
        // 멤버선언
    }
    이름이 없으니 생성자도 가질 수 없고, 하나의 클래스로 상속받는 동시에 인터페이스를 구현하거나 하나 이상의 인터페이스 구현 불가.
    오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있음.
    
    class InnerEx6 {
        Object iv = new Object() { void mothod(){} }; // 익명클래스
        static Object cv = new Object(){ void method(){} }; // 익명클래스
        void myMethod() {
            Object lv = new Object(){ void mothod(){} }; // 익명클래스
        }
    }

컬렉션 프레임웍(440p)
    자바에서는 다양한 패키지(Java API)가 제공됨. 아래와 같이 세가지그룹으로 소개.
    1. 컬렉션 프레임웍 : 다수의 데이터를 쉽게 처리할 수 있는 표준화된 방법을 제공하는 클래스들.
    2. 유용한 클래스 : 알아두면 좋은 자주쓰이는 클래스들
    3. 형식화 클래스 : 데이터를 표준화된 형식으로 출력하는 데 도움을 주는 클래스들

    컬렉션 프레임웍이란 데이터 군을 저장하는 클래스들을 표준화한 설계. 
    * 컬렉션 : 다수의 데이터, 즉 데이터 그룹
    * 프레임웍 : 표준화된 프로그래밍 방식

컬렉션 프레임웍의 핵심 인터페이스 - List, Set, Map(442p)
    컬렉션을 크게 3가지 타입이 존재한다고 인식하고 3개 인터페이스를 정의했음.
        [Collection]          [Map]
        ->        <-
    [List]          [Set]

    List : 순서가 있는 데이터의 집합. 데이터의 중복을 허용함.
           구현클래스 - ArrayList, LinkedList, Stack, Vector등
    Set : 순서를 유지하지 않는 데이터의 집합. 데이터 중복 허용하지않음.
           구현클래스 - HashSet, TreeSet 등
    Map : 키와 값이 쌍으로 이루어진 데이터의 집합. 순서는 유지되지 않으며 키 중복허용하지않음.
           구현클래스 - HashMap, TreeMap, Hashtable, Properties등

    Collection인터페이스 : add, clear, equals 등...
    List인터페이스 : add, get, indexOf 등...
    Set인터페이스 : HashSet, TreeSet등...
    Map인터페이스 : clear, containsKey 등...
    Map.Entry인터페이스 : Map인터페이스의 내부 인터페이스. equals, getKey 등...

동기화(447p)
    멀티쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시 접근할 수 있어 데이터의 일관성을 유지하기위해 동기화가 필요함.
    Vector와 Hashtable과 같은 구버전 클래스는 자체적으로 동기화처리가 되어있으나 멀티쓰레드 프로그래밍이 아닌 경우 성능을 떨어뜨리기 때문에 ArrayList, HashMap을 권장.
    java.util.Collections클래스의 동기화 메소드를 사용하면 됨.
    List list = Collections.synchronizedList(new ArrayList(...));

Vector와 ArrayList(448p)
    둘 다 List인터페이스를 구현해서 데이터 저장순서가 유지되고 중복을 허용한다는 공통적인 특징이 있음 + 데이터의 저장 공간으로 배열을 사용.
    차이점으로는 멀티쓰레드에 대한 동기화 여부.
    ArrayList를 생성할 때 저장할 요소 갯수보다 조금 여유있는 크기로 하는게 좋음. 자동적으로 크기가 늘어나기는 하나 이 과정에서 처리시간이 많이 소요되기 때문.
    * 참고 - 깊은복사(deep copy) : 원본과 같은 데이터를 저장하고있는 새로운 객체나 배열을 생성, 얕은복사(shallow copy) : 단순히 참조만 복사

LinkedList(463p)
    크기를 변경할 수 없고, 비순차적인 데이터의 추가/삭제에 시간이 많이 걸리는 기존 배열의 단점을 보완하기위해 고안됨.
    배열은 모든 데이터가 연속적으로 존재하나 링크드리스트는 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어있음. 삽입/삭제 속도가 매우 빠름.
    다만 이동방향이 단방향이라 다음 요소에 대한 접근은 쉽지만 이전요소에대한 접근은 어려움. 이 점을 보완한 것이 더블 링크드리스트(이중연결리스트). 그걸 업글한게 더블 써큘러 링크드리스트.
    - 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠름
    - 중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠름

Stack과 Queue(471p)
    스택 : 마지막에 저장한 데이터를 가장 먼저 꺼내는 LIFO(Last In First Out)구조.
    큐 : 처음에 저장한 데이터를 가장 먼저 꺼내는 FIFO(First In First Out)구조.

Enumeration, Iterator, ListIterator(480p)
    Iterator : 컬렉션에 저장된 요소들을 읽어옴(단방향)
    Enumeration : Iterator의 구버전.
    ListIterator : Iterator를 상속받아 기능을 추가한 것으로, 양방향으로의 이동이 가능함.

HashSet(490p)
    Set인터페이스를 구현한 대표적인 컬렉션. Set의 특징과 같이 중복된 요소를 저장하지 않음.

TreeSet(499p)
    이진검색트리(binary search tree)라는 자료구조 형태로 데이터를 저장하는 컬렉션 클래스. TreeSet은 이진검색트리를 향상시킨 레드-블랙 트리로 구현되어있음.
    * 이진검색트리 : 정렬, 검색, 범위검색에 뛰어난 성능을 보이는 자료구조.

Comparator와 Comparable(505p)
    모두 인터페이스로 객체들을 정렬 또는 이진검색트리를 구성하는 데 필요한 메소드를 정의하고 있음. 
    Comparator : 기본 정렬기준 외 다른 기준으로 정렬하고자 할 때 사용.
    Comparable : 기본 정렬기준을 구현하는 데 사용.

Hashtable과 MashMap(508p)
    Hashtable보다는 새로운 버전인 HashMap사용을 권장(Vector와 ArrayList관계와 같음).
    Map의 특징인 key-value, 그리고 해싱을 사용해서 많은 양의 데이터를 검색하는 데 있어 뛰어난 성능을 보임.

TreeMap(518p)
    이진검색트리 형태로 키-값 쌍으로 이루어진 데이터 저장. 그래서 검색과 정렬에 적합. 
    검색에 관한 한 HashMap이 더 뛰어나므로 HashMap을 쓰는게 좋음. 다만 범위검색이나 정렬이 필요한 경우에는 TreeMap사용 권장.

Properties(521p)
    HashMap의 구버전인 Hashtable을 상속받아 구현한 것으로, Hashtable은 키-값을 Object, Object형태로 저장하는데비해 String, String 형태로 저장하는 보다 단순화된 컬렉션클래스.
    주로 어플리케이션의 환경설정과 관련된 속성을 저장하는 데 사용되고 데이터를 파일로부터 읽고 쓰는 편리한 기능 제공.

컬렉션클래스 정리&요약(527p)
            ArrayList     추가/삭제기능 향상
              Vector        =======>           LinkedList       ==========>     Queue
            (Object[])
        <====      ====>                <======         ======>         TreeMap
    Stack               HashMap                                             ======>
                        Hashtable                                               TreeSet
                    (Object, Object)
            <====    <====         ======>
    Properties      LinkedHashMap       HashSet =====> LinkedHashSet
    (String,String)

제네릭스(Generics)(589p)
    다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입체크를 해주는 기능. 객체의 타입을 컴파일 시에 체크해서 타입 안정성을 높이고 형변환의 번거로움이 줄어듬.
    즉, 다룰 객체의 타입을 미리 명시해줌으로써 형변환을 하지 않아도 된다는 것.
    제네릭스에서는 참조형 타입, 즉 타입을 의미하는 기호로 T를 씀. 어떠한 참조형 타입도 가능하다는 뜻. 때때로 요소(E), 키(K), 값(V)도 쓰는데 기호만다르고 '임의의 참조형 타입'.
    - 타입 안정성을 제공.
    - 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해짐.
    
    ArrayList<E> : 요소를 뜻하는 element의 약자. E 대신 어떤 문자를 써도 상관은없으나 일관된 문자를 사용해야됨. ex)ArrayList<Product> list = new ArrayList<TV>();
    Iterator<E>
    Comparable<T> 와 Collections.sort() : 클래스의 기본정렬기준 구현. 
    HashMap<K,V>

프로세스와 쓰레드(633p)
    프로세스 : 실행중인 프로그램. 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 됨.
             프로그램을 수행하는 데 필요한 데이터와 메모리등의 자원 + 쓰레드로 구성되어있음. 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하고, 둘 이상은 멀티쓰레드라고 함.
    쓰레드 : 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것. 

    하나의 프로세스가 가질 수 있는 쓰레드의 갯수는 제한되어있지 않으나 쓰레드는 작업할 때 개별적인 메모리공간(호출스택)을 필요로 하기 때문에 프로세스의 메모리 한계에 따라 쓰레드 갯수 한계가 결정됨.
    윈도우나 유닉스 등 대부분의 OS는 멀티태스킹을 지원하여 여러 개의 프로세스가 동시에 실행될 수 있음.
    실제로는 한개의 CPU가 한번에 단 한가지 작업만 할 수 있어 아주 짧은 시간 동안 여러 작업을 번갈아 수행해서 동시에 여러 작업이 수행되는 것처럼 보이는 것임.
    
    멀티쓰레딩 장점.
    1. CPU의 사용률을 향상시킴.
    2. 자원을 보다 효율적으로 사용 가능
    3. 사용자에 대한 응답성이 향상됨
    4. 작업이 분리되어 코드가 간결해짐.
    예를 들어 메신저로 채팅하면서 파일 다운받는게 멀티쓰레드. 싱글쓰레드라면 파일을 다운받는동안 채팅이 불가능.
    여러 사용자에게 서비스를 해주는 서버프로그램의 경우 멀티쓰레드로 작성하는게 필수적임. 다만 동기화, 교착상태 같은 문제들을 고려해서 신중히 프로그래밍해야됨.

쓰레드의 구현과 실행(635p)
    Thread클래스를 상속받는 방법 / Runnable인터페이스를 구현하는방법 2가지가 있음. 
    어느 쪽을 사용해도 크게 차이는 없으나 Thread클래스를 상속받으면 다른 클래스 상속이 불가능해서 Runnable인터페이스 구현이 일반적임.
    class ThreadEx1_2 implements Runnable {
        public void run() {
            for(int i=0; i<5; i++) {
                // Thread.currentThread() - 현재 실행중인 Thread반환
                System.out.println(Thread.currentThread().getName());
            }
        }
    }

쓰레드 - start()와 run()(639p)
    쓰레드를 실행시킬 때 run()이 아닌 start()를 호출함.
    run()을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아닌 단순히 클래스에 속한 메소드 하나를 호출하는 것.
    satrt()를 호출하는 것은 새로운 쓰레드가 작업을 실행하는 데 필요한 호출스택(call stack)을 생성한 다음 run()을 호출해서, 생성된 호출스택에 run()이 첫번째로 저장되게함.

    1. main메소드에서 쓰레드의 start메소드를 호출
    2. start메소드는 쓰레드가 작업을 수행하는 데 사용될 새로운 호출스택을 생성함.
    3. 생성된 호출스택에 run메소드를 호출해서 쓰레드가 작업을 수행하도록 함.
    4. 이제는 호출스택에 2개이기 때문에 스케줄러가 정한 순서에 의해 번갈아가며 실행됨.

싱글쓰레드와 멀티쓰레드(643p)
    싱글쓰레드 - 한 작업을 마친 후 다른 작업 시작
    멀티쓰레드 - 짧은 시간동안 2개의 쓰레드가 번갈아가면서 작업 수행. 짧아서 동시에 두 작업이 처리되는 것과 같이 느껴짐.

쓰레드의 우선순위(649p)
    쓰레드는 우선순위라는 속성(멤버변수)를 가지고 있는데 이것에 따라 쓰레드가 얻는 실행시간이 달라짐. 서로 우선순위를 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록할 수 있음.
    void setPriority(int newPriority); int getPriority(); // 쓰레드 우선순위 값 변경, 우선순위 반환

쓰레드 그룹(651p)
    서로 관련된 쓰레드를 그룹으로 다루기 위한 것. 그룹 안에 다른 그룹도 포함 가능. ThreadGroup을 사용해서 생성 가능.

데몬 쓰레드(654p)
    데몬 쓰레드는 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드. 그래서 일반 쓰레드가 종료되면 데몬 쓰레드는 강제적으로 자동종료됨(보조가 필요없어서).
    그 점을 제외하면 일반쓰레드와 동일함.(ex.가비지 컬렉터, 워드프로세서 자동저장, 화면자동갱신 등)
    무한루프와 조건문을 이용해서 실행 후 대기하고있다가 특정 조건이 만족되면 작업을 수행하고 다시 대기하도록 작성함.(데몬쓰레드가 생성한 쓰레드는 자동으로 데몬쓰레드가 됨)

쓰레드의 실행제어(658p)






* 참고
    [+1와 ++의 차이]
    c + 1은 c의 값을 변화시키지 않고 단순히 계산 결과를 반환
    c++는 c의 값을 변화시키고, 그 변화된 값은 이후 연산에서 유지됨



--------------------------------------------------------------------------------------------------------------------

* 메소드
charAt(int idx) : 문자열중에 idx 위치에 있는 문자를 반환
JOptionPane.showInputDialog : 입력창에서 입력받기